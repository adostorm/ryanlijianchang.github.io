{"meta":{"title":"Ryan's Blog","subtitle":null,"description":null,"author":"Ryan Lee","url":"http://yoursite.com"},"pages":[{"title":"学习","date":"2018-01-11T09:17:12.000Z","updated":"2018-01-11T09:17:12.341Z","comments":true,"path":"学习/index.html","permalink":"http://yoursite.com/学习/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-01-11T09:07:38.000Z","updated":"2018-01-11T09:07:38.462Z","comments":true,"path":"关于/index.html","permalink":"http://yoursite.com/关于/index.html","excerpt":"","text":""},{"title":"生活","date":"2018-01-11T09:07:32.000Z","updated":"2018-01-11T09:07:32.375Z","comments":true,"path":"生活/index.html","permalink":"http://yoursite.com/生活/index.html","excerpt":"","text":""}],"posts":[{"title":"2018，你该搭建自己的博客了！","slug":"2018，你该搭建自己的博客了！","date":"2018-01-10T08:56:29.000Z","updated":"2018-01-12T09:58:29.125Z","comments":true,"path":"2018/01/10/2018，你该搭建自己的博客了！/","link":"","permalink":"http://yoursite.com/2018/01/10/2018，你该搭建自己的博客了！/","excerpt":"","text":"首先欢迎各位来参观我的博客：Ryane’s Blog 摘要：这是一篇有关如何使用Github Pages和Hexo搭建自己独立博客的详尽教程，里面介绍了如何使用和配置Hexo框架，如何将Hexo部署到自己的Github项目中，域名注册，以及域名的绑定，还有我在搭建自己博客过程中所遇到的各种困难。 前言我是一名安卓入门开发者，但，我只是入门！而且我对网站开发以及前端的知识几乎是零基础，所以在自己刚接触这个东西的时候，我像很多人一样，都是上网找教程，但是要知道，那都是程序员的教程。所以对于我这个网站技术小白来说，真是很难受，所以藉此机会写一篇让小白看得懂的教程。如果你是一个小白而且又想做自己的博客，可以，请跟着我的脚步，我会带你真真正正做一个属于你自己的博客。 如果你还不知道你为什么要做一个博客，推荐你看：《我为什么写博客》 入门门槛 必须耐得住折腾。 刻苦的学习精神和耐心。 关于Github 一、Github的优点 GitHub是基于git实现的代码托管。git可能是目前最好用的版本控制系统了，非常受欢迎。 GitHub可以免费使用，并且快速稳定。 Github上面的世界很精彩，用久了你的眼界会开阔很多。 二、什么是Github PagesGithub Pages可以被认为是用户编写的、托管在github上的静态网页。 三、为什么要使用Github Pages 可以绑定你的域名(但暂时貌似只能绑定一个)。 简单快捷，使用Github Pages可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。 安装Node.js在 Windows 环境下安装 Node.js 非常简单，仅须到官网下载安装文件并执行即可完成安装。像我的是Windows 64位，直接下载安装，无脑下一步就行了，不需要配置环境变量。 安装Git去Git官网根据你的电脑参数，下载对应版本。 下载完成，通过在命令行输入 git version 查看是否安装成功，有输出版本号说明安装成功。 鼠标邮件菜单里就多了Git GUI Here和Git Bash Here两个按钮，一个是图形界面的Git操作，一个是命令行，我们选择Git Bash Here。 安装教程：如何在windows下安装GIT Git入门教程：Pro Git（中文版） Git基本操作： HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 一、Hexo安装桌面右键鼠标，点击Git Bash Here，输入npm命令即可安装 npm install hexo-cli -g npm install hexo-deployer-git --save 第一句是安装hexo，第二句是安装hexo部署到git page的deployer，两个都需要安装。 如下图即安装完成。 二、Hexo初始化配置创建Hexo文件夹安装完成后，根据自己喜好建立目录（如F:\\Blog\\Hexo），直接进入F:\\Blog\\Hexo文件夹下右键鼠标，点击Git Bash Here，进入Git命令框，执行以下操作。 $ hexo init 安装 Hexo 完成后，Hexo 将会在指定文件夹中新建所需要的文件。Hexo文件夹下的目录如下： 本地查看效果执行下面语句，执行完即可登录localhost:4000查看效果 hexo generate hexo server 登录localhost:4000，即可看到本地的效果如下： 将博客部署到Github Pages上那么现在本地的博客已经搭建起来了，但是我们只可以通过本地连接查看我们的博客。那么我们现在需要做的就是把本地的博客发布到服务器上，让别人也可以连接我们的博客，而Github Pages就帮我完成了这件事情。但是Github Pages的代码就是寄存在Github上面的。那么接下来我们需要在Github上面创建一个新的项目。 一、注册Github账户 访问Github首页 点击右上角的 Sign Up，注册自己的账户 二、创建项目代码库 注册完登陆后，我们就创建一个我们自己的Github Pages项目。点击New repository。 创建要点如下： 三、配置SSH密钥配置Github的SSH密钥可以让本地git项目与远程的github建立联系，让我们在本地写了代码之后直接通过git操作就可以实现本地代码库与Github代码库同步。操作如下： 第一步、看看是否存在SSH密钥(keys)首先，我们需要看看是否看看本机是否存在SSH keys,打开Git Bash,并运行: $ cd ~/. ssh 检查你本机用户home目录下是否存在.ssh目录 如果，不存在此目录，则进行第二步操作，否则，你本机已经存在ssh公钥和私钥，可以略过第二步，直接进入第三步操作。 第二步、创建一对新的SSH密钥(keys)$ssh-keygen -t rsa -C &quot;your_email@example.com&quot; #这将按照你提供的邮箱地址，创建一对密钥 Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter] 直接回车，则将密钥按默认文件进行存储。此时也可以输入特定的文件名，比如/c/Users/you/.ssh/github_rsa 接着，根据提示，你需要输入密码和确认密码（说到这里，如果你很放心，其实可以不用密码，就是到输密码的地方，都直接回车，所以每次push就只管回车就行了。所谓的最安全的密码，就是没有密码 哈哈）。相关提示如下： Enter passphrase (empty for no passphrase): [Type a passphrase] Enter same passphrase again: [Type passphrase again] 输入完成之后，屏幕会显示如下信息： Your identification has been saved in /c/Users/you/.ssh/id_rsa. Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub. The key fingerprint is: 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 第三步、在GitHub账户中添加你的公钥运行如下命令，将公钥的内容复制到系统粘贴板(clipboard)中。 clip &lt; ~/.ssh/id_rsa.pub 接着： 登陆GitHub,进入你的Account Settings. 2.选择SSH Keys 3.粘贴密钥，添加即可 第四步、测试可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改： $ ssh -T git@github.com 如果是下面的反馈： The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established. RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. Are you sure you want to continue connecting (yes/no)? 不要紧张，输入yes就好，然后会看到： 第五步、设置用户信息现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字根据自己的喜好自己取，而不是GitHub的昵称。 $ git config --global user.name &quot;ryanlijianchang&quot;//用户名 $ git config --global user.email &quot;liji.anchang@163.com&quot;//填写自己的邮箱 第六步、SSH Key配置成功本机已成功连接到github。 四、将本地的Hexo文件更新到Github的库中第一步、登录Github打开自己的项目 username.github.io 第二步、打开之后，点击SSH，选择SSH类型地址 第三步、复制地址 第四步、打开你一开始创建的Hexo文件夹（如F:\\Blog\\Hexo），用记事本打开刚文件夹下的_config.yml文件 第五步、在配置文件里作如下修改，保存 第六步、在Hexo文件夹下执行：hexo g hexo d 或者直接执行 hexo g -d 执行完之后会让你输入github的账号和密码，输入完后就可以登录我们自己的部署在Github Pages服务器上的博客了。对应的地址是 username.github.io(我的是：ryanlijianchang.github.io)。 假如这时候，报错 ERROR Deployer not found: git，那么就是你的deployer没有安装成功，你需要执行如下命令再安装一次： npm install hexo-deployer-git --save 这样，你再执行hexo g -d，你的博客就部署到Github上了。 第七步、在浏览器上输入自己的主页地址在浏览器上输入Github Pager为我们生成的外链（例如我的是：https://ryanlijianchang.github.io/，而你的只需要把你的github用户名替换掉这个链接中的ryanlijianchang，因为我的用户名是这个，那么你自己的专属博客地址就是：https://[您的用户名].github.io/）即可看到自己的博客了。 当然，每一个人都可以通过这个地址访问到你的博客了。 美化自己博客那么现在我们的博客已经挂在了Github服务器上面，别人已经可以通过地址来登陆我们的博客了，但是我们这时就有了新的需求，就是自己的博客并不好看，那怎么办的？这很简单，要知道很多前端开发者在Hexo框架下开发了很多的主题给我们使用，我们只需要把他们的主题克隆过来，然后通过修改配置文件即可达到我们所需要的效果。 那么我们应该怎么修改呢？ 一、进入Hexo的官网主题专栏 二、挑选我们喜欢的主题可以看到有很多主题给我们选，我们只要选择喜欢的主题点击进去，然后进入到它的github地址，我们只要把这个地址复制下来(例如我是选择：hexo-theme-next这个主题) 三、克隆主题再打开Hexo文件夹下的themes目录（F:\\Blog\\hexo\\themes），右键Git Bash，在命令行输入: git clone https://github.com/iissnan/hexo-theme-next(此处地址替换成你需要使用的主题的地址) 下载中，等待下载完成： 四、修改Hexo配置文件下载完成后，打开Hexo文件夹下的配置文件_config.yml 修改参数为：theme: hexo-theme-next 五、部署主题，本地查看效果返回Hexo目录，右键Git Bash，输入 hexo g hexo s 打开浏览器，输入 http://localhost:4000/ 即可看见我们的主题已经更换了。 六、如果效果满意，将它部署到Github上打开Hexo文件夹，右键Git Bash，输入 hexo clean (必须要，不然有时因为缓存问题，服务器更新不了主题) hexo g -d 七、打开自己的主页，即可看到修改后的效果更多修改效果请查看对应主题的说明文档，点击此查看本主题(Next)对应的说明文档。 在博客写文章一、用hexo发表新文章$ hexo n &quot;文章标题&quot; 其中 我的家 为文章标题，执行命令 hexo n &quot;我的家&quot; 后，会在项目 \\Hexo\\source_posts 中生成 我的家.md文件，用编辑器打开编写即可。 当然，也可以直接在\\Hexo\\source_posts中新建一个md文件，我就是这么做的。写完后，推送到服务器上，执行以下命令即可在我们的站点看到新的文章。 $ hexo g #生成 $ hexo d #部署 # 可与hexo g合并为 hexo d -g 二、用Markdown写文章我们注意到在 \\Hexo\\source_posts 文件夹下存放着我们的文章，它们的格式都是以.md格式结尾的，没错，Hexo也是支持Markdown语法的，所以当我们需要写具有格式化的文章时，我们可以使用支持Markdown语法的编辑器进行文章编译，然后保存文件到 \\Hexo\\source_posts 文件夹下即可。 复制进去之后，只要执行 $ hexo d -g 推送到我们的Github仓库即可。 那么什么是Markdown？Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。 Markdown有什么优点？ 专注你的文字内容而不是排版样式。 轻松的导出 HTML、PDF 和本身的 .md 文件。 纯文本内容，兼容所有的文本编辑器与字处理软件。 可读，直观。适合所有人的写作语言。 我该用什么工具？ Windows下可以使用 MarkdownPad2。 在 Mac OS X 上，我建议你用 Mou 这款免费且十分好用的 Markdown 编辑器。 Web 端上，我强烈推荐 简书 这款产品。 关于Markdown的更多资料可以查看如下： 认识与入门 Markdown Markdown入门指南 将自己的域名关联到Github Pages上很多朋友创建了自己的博客之后会选择买一个属于自己的域名，然后将自己域名绑定到自己的Github Pages博客上，其实这也并不难，只要你有个域名。 一、购买域名如果你不是很有钱，在阿里云上，你只要几块钱就可以买到一个域名。 选择你喜欢的域名，然后购买即可。 二、配置CNAME文件在 \\hexo\\source 文件夹下创建文件 CNAME （新建记事本文件命名CNAME，然后打开） 内容为你的域名，例如我的域名是：ryane.top 在Hexo文件夹提交 hexo g -d 三、修改DNS的DNS1.如果你是在阿里云购买域名的话，请登录阿里云网站。打开个人中心，点击域名 2.选择管理 3.修改DNS为 f1g1ns2.dnspod.net f1g1ns1.dnspod.net 四、域名解析 打开DNSPOD，注册一个账户 点击添加域名，把你的域名添加进去，如无意外，添加完之后就是以下这个状态 此时点击添加记录，添加两个记录，一个主机记录为@， 一个为www，而记录值都是填同一个，填你的博客主页对应的ip，添加完后如下。 但是如何获取ip值呢？打开运行，输入cmd，打开命令窗口输入 ping 主页地址 ， 红色部分即为你的ip值 将IP输入过去，然后会提示你到域名注册的地方修改DNS。等待生效，最迟72小时生效。即可通过你的域名浏览你的博客主页。 结语当你完成了你的博客之后，相信你的心情跟我刚做完的心情是一样的，即便很累，但是当自己的博客成型之后，自己还是有一个成就感的，那么完成后，以后的路还很长，真正想要自己博客能够积累人气，还得靠好的内容，所以认真写文章吧，相信你会受益于此的。 如果大家有什么问题的话，可以在我留言板下留言，我看到评论时会第一时间回答大家。 参考资料： Markdown入门手册中文版 Markdown–入门指南 如何搭建一个独立博客——简明 Github Pages与 jekyll 教程 by cnfeat Hexo搭建Github静态博客 by 金石开 使用SSH密钥连接Github【图文教程】 by 轩枫","categories":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/学习/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/学习/"}]},{"title":"生活在孤独中前行","slug":"生活在孤独中前行","date":"2018-01-05T08:56:29.000Z","updated":"2018-01-12T09:49:08.454Z","comments":true,"path":"2018/01/05/生活在孤独中前行/","link":"","permalink":"http://yoursite.com/2018/01/05/生活在孤独中前行/","excerpt":"","text":"Tips：一边听下面的音频一边看会更有感觉！主播叫做NJ瓜瓜。 生活不可能像你想象得那么好，但也不会像你想象得那么糟。我觉得人的脆弱和坚强都超乎自己的想象。有时，我可能脆弱得一句话就泪流满面，有时，也发现自己咬着牙走了很长的路。——莫泊桑 以这一句话开始，是因为看了高木直子的《一个人住第五年》。都说人是慢慢成长的，其实不是，人是瞬间长大的，就像是突然间沉淀一般，突然不会谈恋爱了或者说不想谈恋爱了，一个人生活单一却也不会觉得无聊，即便很多时候还是会迷茫却也不会觉得烦躁了。去年的今天我在不一样的城市，背着不一样的书包，留着不一样的发型，走着不一样的路，想着不一样的事情，有着不一样的心思，谁说改变要十年呢。或者说，这一秒的想法和上一秒的想法就不一样，这个世界是瞬间变化的，运转速度是那么快，没有人在意你是不是一个人。而我呢，就是一个人，默默地在做自己的事，感受着生活中的变化，也感受着自己的变化，在不断的变化中，寻找最佳的结合点和平衡点。信奉一句话：变化中求生存。专注和节奏是生活的主旋律。 身边的牛人倒是不少，像是神抵一样的存在，我也只是羡慕想着反正自己也不会变成那样的人，直到有一天跟国内比较有影响力28岁的年轻总裁聊天，才知道原来他也有看不进去书，经常想方案想到撞墙的时候，我们都忘了他们是用怎么样的一个代价才换取来了这样的一个人生。他说，如果你想要去实现梦想，孤独是你的必修课。如果不能沉下心来，就没有办法去实现它，因为那绝对不是一件容易的事情，孤独能让你更坚强，你必须找到自己的生活节奏。 最近迷上一个人到处走，算不上旅行只是周围到处走一走，倒也不会花上太多时间准备，起身就走了。我不会带上相机只是有兴致了拿出手机拍一拍，音乐倒是我走到哪里都不能丢的东西，每个月都会去听几场音乐会，只有音乐，能让看似漫长的等待变成曼妙的旅程，似乎自己跟整个世界都没有关系，只想当一片没有名字的云，徜徉在不知道名字的风景里。我们都会找到自己的生活节奏，然后沉溺其中无法自拔。 曾经学生时代很少去图书馆，觉得那种“每个星期读一本书”对于我来讲有点勉强。但之后的某一天我陪朋友去图书馆，他是一个借书就不会停的人，我也就跟着借了几本。回到家里看微博人人又觉得心里空当当的，索性就拿起书来看，也是在那一天我才发现，其实每个星期看一本书没那么难，那天我一下子把书看完，才觉得这样子的生活是充实的。所以我喜欢读书，读很多书，尽管现在时间很紧，有时候忙得让自己无法开胶，但每天还是会抽出一点时间来，看看书。 要么读书，要么旅行，身体和灵魂，必须有一个在路上。 我告诉自己现实容不得你拖延，拖延只会让我变得更焦虑而已，所以刚开始的时候我规定自己每天提早上床半小时，看上几十页书，很快就变成习惯了。有的时候我不得不感叹如果真的去做一件事情的话，那么这件事情没有那么难。当你真的想要做一件事情的时候，整个世界都会来协助你，就是这种感觉。想起了09年艺考备战时，想起了面试节目时，经常告诉自己的一句话：当你只有一个目标时，全世界都会为你让路。 一个喜欢冒险和旅游的朋友说，只要出发，就能到达，你不出发，就哪里也去不了。如果你不能沉下心来，就什么也做不到。出发永远是最有意义的事，去做就是了。一本书买了不看只是几张纸，公开课下了不看也只是一堆数据，不去看就没有任何意义，反而徒增焦虑，行动力才是最关键的。 你也许也是这样，当你渴望找个人交谈的时候，你们却没有谈什么，于是发现有些事情是不能告诉别人的，有些事情是不必告诉别人的，有些事情是根本没有办法告诉别人的，而有些事情即使告诉了别人，你也会马上后悔，那么最好的办法就是静下来，真正能平静自己的只有自己。 没有人能免得了孤独，与其逃避它不如面对它。孤独并不是一件那么糟糕的事情，与嘈杂相比，一个人生活倒显得自得地多，倒也可以变成一种享受。或许至少需要那么一段时间，几年或几个月，一个人生活，不然怎么能找到自己的节奏知道自己想要什么。这是属于你自己的东西，是你的一部分，你听音乐时，坐地铁时，一个人走在马路上时，它就会流淌出来，让我觉得这个世界似乎在以另外一种形式存在着，我能够清晰地听到自己，不断地在和自己对话交流。所以，我很喜欢独处，喜欢一个人漫无目的的随便走走。 我们都生活在一个不那么如意的世界，当乌云密布我们就摇曳，但阳光总有一天会到来，等阳光照到你的时候，记得开出自己的花就行了，那个你与生俱来的梦想。有的时候梦想很远，有的时候梦想很近，但它总会实现的。我想一个人最好的样子就是平静一点，哪怕一个人生活，穿越一个又一个城市，走过一个又一条街道，仰望一片又一片天空，见证一次又一次别离。 即便世界与我为敌，只要心还透明，就能折射希望。 接下来说说“选择”，选择，是一门艺术，一种技巧，一种生活的情调。什么都有正反两面，有些是我们能把握控制的，有些是我们不能左右的，但是我们有选择的权利，可以选择我们自己的生活。小处说，可以选择一种心情，一件衣服，甚至中午我们要吃什么饭，大处讲，我们可以选择一段感情，一种方式，一种习惯，一种性格，一种态度，一种人生。而这一切的出发点都是我们的内心，依据内心和环境而做出的选择。选择的任何一种形式都要为我们的结果服务的，不然选择就毫无意义，通常我们会采用两种方式思考问题和做出选择：基于自己的真实想法和基于事情的后果。但是都要归到一个点上，你要为你的选择买单。 如果你感觉你会后悔，那么你就不要去选择；如果你选择了，你就永远不要后悔。 然后就是“比较”比较，是一门哲学。比较就像一面镜子，可以知得失，知利弊，知不足，知缺点也知优点。比较是自己的一部历史，给你经验，给你教训，让你更加了解你自己，进而完善自己。在和周围的比较时，别忘了和昨天的你做比较，这样会进步更快。 “变化”，上边已经提到一点，变化其实才是生活的实质，人是在变化的，生活是在变化的，社会是在变化的，整个世界也在不断的变化，而你要不要变化？？？要不要去适应这个世界，赶上节奏？？？当你一种不好的习惯或者性格，把你的而生活搞得很糟糕时，你还在怂恿它，不想改变，为什么？？你已经很清洗地认识到它的弊端了，为什么不变？？当它直到有一天，事情搞到无法挽救的地步，你才想起要改变，是不是有点晚了。人的惰性和致命弱点。这或许我们每个人都经历过，才会一步一步长大成熟。穷则思变，穷则生变，有变才有进步。变，是一种考验和磨练，让你坚强，让你自信，让你成熟。 一个人的思想和认识的变化对他来说，很重要。只有思想上的变革才会有行为上的变化。其实也就是我们所说的想与做的问题，但是一般人所说的想，只是随便的想一想，并没有深入到根本本质的东西，没有认真的分析，要做成一件事，需要什么样的思想、认识，需要什么环境、条件，还有需要自身什么精神或者品质、习惯（如坚持、吃苦、坚强、勤奋、激情等等）这可以说也是一个逻辑思维的过程，但却是做成一件事必不可缺少的过程。想起来电视上狄仁杰说过的一句话：想做成一件事要有三断——判断、推断、果断。也如现在人们所说的三力——判断力、分析力、执行力，所以什么事都不是那么简简单单容易的就做成的，需要你做的很多。 对于“简单”来说，不同的人有不同的认识，一千个读者一千个哈姆雷特。真正的大家、智者、老者所认为的简单，其实是不简单。简单是从复杂中提炼出来的，没有经过复杂哪里来的简单。与其说简单是一种幸福，不如说经历复杂是一种幸福。路遥《平凡世界》上有一句关于幸福的解释，值得借鉴：幸福不只是吃饱穿暖，而是勇敢地去战胜困难，一点一点地不断超越自己！ “平衡”我对平衡感要求很高的，这种思想是我从生态学上学到的，我认为生态学中有一种思想就是平衡和和谐。任何一个环境，包括我们人类所生活的社会环境，都需要在一个平衡和谐的状态下才能持久下去，不然都会被淘汰的，针对一个人个体上说也是一样的，你如果不能保持你内心的一种平衡，你肯定会抱怨的，每个人都一样，都会这样的。那我们该怎样做，才能是我们的身与心、内与外的平衡和谐呢。这是我们要找的东西，因人而异，要量体裁衣。 那么孤独是人生的一部分，缺少了孤独，似乎人生也就不完美了，所以我们应该习惯孤独，爱上孤独，它能告诉你很多人生的秘密。相信我。","categories":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/生活/"}],"tags":[{"name":"鸡汤","slug":"鸡汤","permalink":"http://yoursite.com/tags/鸡汤/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/生活/"}]},{"title":"用RecyclerView做一个小清新的Gallery效果","slug":"用RecyclerView做一个小清新的Gallery效果","date":"2017-12-14T16:00:00.000Z","updated":"2018-01-11T09:41:10.594Z","comments":true,"path":"2017/12/15/用RecyclerView做一个小清新的Gallery效果/","link":"","permalink":"http://yoursite.com/2017/12/15/用RecyclerView做一个小清新的Gallery效果/","excerpt":"","text":"一、简介RecyclerView现在已经是越来越强大，且不说已经被大家用到滚瓜烂熟的代替ListView的基础功能，现在RecyclerView还可以取代ViewPager实现Banner效果，当然，以下做的小清新的Gallery效果也是类似于一些轮播图的效果，如下图所示，这其中使用到了24.2.0版本后RecyclerView增加的SnapHelper这个辅助类，在实现以下效果起来也是非常简单。所以这也是为什么RecyclerView强大之处，因为Google一直在对RecyclerView不断地进行更新补充，从而它内部的API也是越来越丰富。 那么我们从水平滑动为例，我们细分为以下几个小问题： 每一次滑动都让图片保持在正中间。 第一张图片的左边距和最后一张的右边距需要保持和其他照片的左右边距一样。 滑动时，中间图片滑动到左边时从大变小，右边图片滑动到中间时从小变大。 背景实现高斯模糊。 滑动结束时背景有一个渐变效果，从上一张图片淡入淡出到当前图片。 二、实现思路解决以上问题当然也不难，我们分步来讲解下实现思路： (1) 每一次滑动都让图片保持在正中间保持让图片保持在正中间，正如简介中所说，在ToolsVersion24.2.0之后，Google给我们提供了一个SnapHelper的辅助类，它只需要几行代码就能帮助我们实现滑动结束时保持在居中位置： LinearSnapHelper mLinearySnapHelper = new LinearSnapHelper(); mLinearySnapHelper.attachToRecyclerView(mGalleryRecyclerView); LinearSnapHelper类继承于SnapHelper，当然SnapHelper还有一个子类，叫做PagerSnapHelper。它们之间的区别是，LinearSnapHelper可以使RecyclerView一次滑动越过多个Item，而PagerSnapHelper像ViewPager一样限制你一次只能滑动一个Item。 (2) 第一张图片的左边距和最后一张的右边距需要保持和其他照片的左右边距一样由于第0个位置，和最后一个位置的图片比较特殊，其他图片都默认设置他们的页边距和左右图片的可视距离，由于第0页左边没有图片，所以左边只有1倍页边距，这样滑动到最左边时看起来就会比较奇怪，如下图所示。 让第0位置的图片左边保持和其他图片一样的距离，那么就需要动态设置第0位置图片的左边距为2倍页边距 + 可视距离。同理，最后一张也是做同样的操作。 动态修改图片的LayoutParams，由于RecyclerView对Holder的复用机制，我们最好不要在Adapter里面动态修改，这样子首先不够优雅，这里感谢@W_BinaryTree的建议，我们给RecyclerView添加一个自定义的Decoration会让我们的代码更加优雅，只需要重写RecyclerView.ItemDecoration里面的getItemOffsets(Rect outRect, final View view, final RecyclerView parent, RecyclerView.State state)方法，并在里面设置每一页的参数即可，修改如下： public class GalleryItemDecoration extends RecyclerView.ItemDecoration { int mPageMargin = 0; // 每一个页面默认页边距 int mLeftPageVisibleWidth = 50; // 中间页面左右两边的页面可见部分宽度 public static int mItemComusemX = 0; // 一页理论消耗距离 @Override public void getItemOffsets(Rect outRect, final View view, final RecyclerView parent, RecyclerView.State state) { super.getItemOffsets(outRect, view, parent, state); // ... // 动态修改页面的宽度 int itemNewWidth = parent.getWidth() - dpToPx(4 * mPageMargin + 2 * mLeftPageVisibleWidth); // 一页理论消耗距离 mItemComusemX = itemNewWidth + OsUtil.dpToPx(2 * mPageMargin); // 第0页和最后一页没有左页面和右页面，让他们保持左边距和右边距和其他项一样 int leftMargin = position == 0 ? dpToPx(mLeftPageVisibleWidth + 2 * mPageMargin) : dpToPx(mPageMargin); int rightMargin = position == itemCount - 1 ? dpToPx(mLeftPageVisibleWidth + 2 * mPageMargin) : dpToPx(mPageMargin); // 设置参数 RecyclerView.LayoutParams lp = (RecyclerView.LayoutParams) itemView.getLayoutParams(); lp.setMargins(leftMargin, 0, rightMargin, 0); lp.width = itemWidth; itemView.setLayoutParams(lp); // ... } public int dpToPx(int dp) { return (int) (dp * Resources.getSystem().getDisplayMetrics().density + 0.5f); } } 然后，把GalleryItemDecoration传入即可： mGalleryRecyclerView.addItemDecoration(new GalleryItemDecoration()); (3) 滑动时，中间图片滑动到左边时从大变小，右边图片滑动到中间时从小变大这个问题涉及到比较多的问题。 (a) 获取滑动过程中当前位置。 首先，RecyclerView当前的API，并不能让我们在滑动的过程中，简单地获取到我们图中效果中间图片的位置，或许你会说，可以通过mGalleryRecyclerView.getLinearLayoutManager().findFirstVisibleItemPosition()能拿到RecyclerView中第一个可见的位置，但是通过效果可以知道，我们每一个张照片（除去第一张和最后一张）左右两边都是有前一张照片和最后一张照片的部分内容的，所以需要做区分判断是否是中间的照片还是第一张亦或最后一张，然后返回mGalleryRecyclerView.getLinearLayoutManager().findFirstVisibleItemPosition() + 1或者其他。 那么这样又会引出一个问题，当我们把前后照片展示的宽度设置成可配置，即前后照片的露出部分宽度是可配置，那么当我们把屏幕不显示前后照片遗留部分在屏幕的话，那么我们这一个方法又不能兼容了，所以通过这一个方法来获取，或许不那么靠谱。 我们可以这样来计算出比较准确的位置。在RecyclerView中，我们可以监听它的滑动事件： // 滑动监听 mGalleryRecyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() { @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) { super.onScrollStateChanged(recyclerView, newState); } @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { super.onScrolled(recyclerView, dx, dy); // 通过dx或者dy来计算位置。 } }); 里面有一个onScrolled(int dx, int dy)方法，这里面的dx，dy非常有用。首先，通过判断dx，dy是否大于0可以判断它是上、下、左、右滑动，dx &gt; 0右滑，反之左滑，dy &gt; 0 下滑，反之上滑（当然，我这里的滑动是相对于RecyclerView，即列表的滑动方向，手指的滑动方向和这里相反）。其次，dx和dy还能监听每一次滑动在x，y轴上消耗的距离。 举个例子，当我们迅速至列表右边时，onScrolled(int dx, int dy)会不断被调用，通过在方法里面Log输出，你会看到不断输出dx的值，而且他们的大小都是无规律的，而这里的dx就是每一次onScroll方法调用一次，RecyclerView在x轴上的消耗距离。 所以我们可以通过一个全局变量mConsumeX来累加所有dx，当这样我们就可以知道当前RecyclerView滑动的总距离。而我们Demo中每移动到下一张照片的距离(即如下图中所示的移动一页理论消耗距离)是一定的，那么就可以通过当前位置 = mConsumeX / 移动一张照片所需要的距离来获取滑动结束时的位置了。 /** * 获取位置 * * @param mConsumeX 实际消耗距离 * @param shouldConsumeX 移动一页理论消耗距离 * @return */ private int getPosition(int mConsumeX, int shouldConsumeX) { float offset = (float) mConsumeX / (float) shouldConsumeX; int position = Math.round(offset); // 四舍五入获取位置 return position; } (b) 根据位置获取当前页的滑动偏移率 当我们可以准确拿到当前位置时，我们就需要明确一下几个概念。 总的偏移距离：意思是从第一个位置移动到现在当前位置偏移的总距离，即dx的累加结果（也就是上述的mConsumX）。 当前页偏移距离：意思是从上一个位置移动到当前位置偏移距离。 总的偏移率：意思是 总的偏移距离 / 移动一页理论消耗距离。 当前页的偏移率：意思是 当前页偏移距离 / 移动一页理论消耗距离。 我们都知道，获取当前位置方法里面有一个 float offset = (float) mConsumeX / (float) shouldConsumeX; 它的意思就是总的偏移率，例如图中我们当前位置是3，我们从3移动到4时，onScroll方法会不断被调用，那么这个offset就会不断变化，从3.0逐渐增加一直到4.0，图中此时的offset大概是3.2左右，我们知道这一个有什么用呢？试想一下，offset是一个浮点型数，将它向下取整，那就是变成3了，那么3.2 - 3 = 0.2就是我们当前页的偏移率了。而我们通过偏移率就可以动态设置图片的大小，就形成了我们这个问题中所说的图片大小变化效果。所以这里的关键就是获取到当前页的偏移率。 @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { super.onScrolled(recyclerView, dx, dy); // ... // 移动一页理论消耗距离 int shouldConsumeX = GalleryItemDecoration.mItemComusemX; // 获取当前的位置 int position = getPosition(mConsumeX, shouldConsumeX); // 位置浮点值（即总消耗距离 / 每一页理论消耗距离 = 一个浮点型的位置值） float offset = (float) mConsumeX / (float) shouldConsumeX; // 避免offset值取整时进一，从而影响了percent值 if (offset &gt;= mGalleryRecyclerView.getLinearLayoutManager().findFirstVisibleItemPosition() + 1 &amp;&amp; slideDirct == SLIDE_RIGHT) { return; } // 当前页的偏移率 float percent = offset - ((int) offset); // 设置动画变化 setAnimation(recyclerView, position, percent); // ... } (c) 根据偏移率实现动画 现在我们拿到了偏移率，就可以动态修改它们的尺寸大小了，首先，我们需要拿到当前View，前一个View和后一个View，并同时对它们做Scale伸缩。即上面的setAnimation(recyclerView, position, percent)方法里面进行动画操作。 View mCurView = recyclerView.getLayoutManager().findViewByPosition(position); // 中间页 View mRightView = recyclerView.getLayoutManager().findViewByPosition(position + 1); // 左边页 View mLeftView = recyclerView.getLayoutManager().findViewByPosition(position - 1); // 右边页 认真观察图中变化，两种变化： 位置的变化：第一张图片是从mCurView慢慢变成mLeftView，而第二张图片是从mRightView慢慢变成mCurView。 大小变化：第一张图是从大变小，第二张图是从小变大。 理解了以上的变化之后，我们就可以做动画了。 首先说明一点，大家观察我的getPosition(mConsumeX, shouldConsumeX)方法，里面的实现是，当一页滑动的偏移率超过了0.5之后，position就会自动切换到下一页。当然你的实现逻辑不一样，那么后面你的设置动画的方法就不一样。为什么需要明确这一点呢？因为当我滑动超过图片超过它的一半宽度之后，上面的mCurView就会切换成下一张图片了，所以我在设置动画的方法里以0.5为一个临界点，因为0.5临界点的两边，mCurView，mRightView，mLeftView的指向都已经不一样了。 假如我们定义大小变化因子 float mAnimFactor = 0.2f，它的意思就是控制我们的图片从1.0伸缩至0.8。以上图为例，当percent &lt;= 0.5时，mCurView的ScaleX和ScaleY从大慢慢变小，至于这个变化范围，就根据我们定义的变化因子和percent来修改；而当percent &gt; 0.5时，刚才那个View就变成了mLeftView，此时我们继续刚才的操作，整个过程我们就实现了第一张图片的Scale从1.0变化到了0.8。而另外两张图片也是同理，大概代码逻辑如下： private void setBottomToTopAnim(RecyclerView recyclerView, int position, float percent) { View mCurView = recyclerView.getLayoutManager().findViewByPosition(position); // 中间页 View mRightView = recyclerView.getLayoutManager().findViewByPosition(position + 1); // 左边页 View mLeftView = recyclerView.getLayoutManager().findViewByPosition(position - 1); // 右边页 if (percent &lt;= 0.5) { if (mLeftView != null) { // 变大 mLeftView.setScaleX((1 - mAnimFactor) + percent * mAnimFactor); mLeftView.setScaleY((1 - mAnimFactor) + percent * mAnimFactor); } if (mCurView != null) { // 变小 mCurView.setScaleX(1 - percent * mAnimFactor); mCurView.setScaleY(1 - percent * mAnimFactor); } if (mRightView != null) { // 变大 mRightView.setScaleX((1 - mAnimFactor) + percent * mAnimFactor); mRightView.setScaleY((1 - mAnimFactor) + percent * mAnimFactor); } } else { if (mLeftView != null) { mLeftView.setScaleX(1 - percent * mAnimFactor); mLeftView.setScaleY(1 - percent * mAnimFactor); } if (mCurView != null) { mCurView.setScaleX((1 - mAnimFactor) + percent * mAnimFactor); mCurView.setScaleY((1 - mAnimFactor) + percent * mAnimFactor); } if (mRightView != null) { mRightView.setScaleX(1 - percent * mAnimFactor); mRightView.setScaleY(1 - percent * mAnimFactor); } } } (4)背景实现高斯模糊高斯模糊有挺多种实现方法的，Google一下就出来了。但是还是推荐Native层的实现算法，因为Java层的实现对性能影响实在太大了，例子里使用的是RenderScript，当然是参考博主湫水的教你一分钟实现动态模糊效果，大家感兴趣可以过去看看，用法也是非常简单。直接调用blurBitmap(Context context, Bitmap image, float blurRadius)方法即可。 public class BlurBitmapUtil { //图片缩放比例 private static final float BITMAP_SCALE = 0.4f; /** * 模糊图片的具体方法 * * @param context 上下文对象 * @param image 需要模糊的图片 * @return 模糊处理后的图片 */ public static Bitmap blurBitmap(Context context, Bitmap image, float blurRadius) { // 计算图片缩小后的长宽 int width = Math.round(image.getWidth() * BITMAP_SCALE); int height = Math.round(image.getHeight() * BITMAP_SCALE); // 将缩小后的图片做为预渲染的图片 Bitmap inputBitmap = Bitmap.createScaledBitmap(image, width, height, false); // 创建一张渲染后的输出图片 Bitmap outputBitmap = Bitmap.createBitmap(inputBitmap); // 创建RenderScript内核对象 RenderScript rs = RenderScript.create(context); // 创建一个模糊效果的RenderScript的工具对象 ScriptIntrinsicBlur blurScript = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs)); // 由于RenderScript并没有使用VM来分配内存,所以需要使用Allocation类来创建和分配内存空间 // 创建Allocation对象的时候其实内存是空的,需要使用copyTo()将数据填充进去 Allocation tmpIn = Allocation.createFromBitmap(rs, inputBitmap); Allocation tmpOut = Allocation.createFromBitmap(rs, outputBitmap); // 设置渲染的模糊程度, 25f是最大模糊度 blurScript.setRadius(blurRadius); // 设置blurScript对象的输入内存 blurScript.setInput(tmpIn); // 将输出数据保存到输出内存中 blurScript.forEach(tmpOut); // 将数据填充到Allocation中 tmpOut.copyTo(outputBitmap); return outputBitmap; } } 这个方法只要传入Context，Bitmap，和一个模糊程度即可，然后返回一个高斯模糊后的Bitmap给我们，我们只需要将RecyclerView的父布局设置背景为这个Bitmap即可。 (5)滑动结束时背景有一个渐变效果，从上一张图片淡入淡出到当前图片实现这个效果最好不要使用Tween动画，因为它的实现效果比较生硬，使用TransitionDrawable会让效果更佳接近淡入淡出效果。那我们怎么记录前后两个位置的照片呢？方法很多种，这里就使用了一个Map来记录每一次显示的图片，在它切换到下一个图片时，便从上一次记录的图片淡入淡出到本次的图片。 // 获取当前位置的图片资源ID int resourceId = ((RecyclerAdapter) mRecyclerView.getAdapter()).getResId(mRecyclerView.getScrolledPosition()); // 将该资源图片转为Bitmap Bitmap resBmp = BitmapFactory.decodeResource(getResources(), resourceId); // 将该Bitmap高斯模糊后返回到resBlurBmp Bitmap resBlurBmp = BlurBitmapUtil.blurBitmap(mRecyclerView.getContext(), resBmp, 15f); // 再将resBlurBmp转为Drawable Drawable resBlurDrawable = new BitmapDrawable(resBlurBmp); // 获取前一页的Drawable Drawable preBlurDrawable = mTSDraCacheMap.get(KEY_PRE_DRAW) == null ? resBlurDrawable : mTSDraCacheMap.get(KEY_PRE_DRAW); /* 以下为淡入淡出效果 */ Drawable[] drawableArr = {preBlurDrawable, resBlurDrawable}; TransitionDrawable transitionDrawable = new TransitionDrawable(drawableArr); mContainer.setBackgroundDrawable(transitionDrawable); transitionDrawable.startTransition(500); // 存入到cache中 mTSDraCacheMap.put(KEY_PRE_DRAW, resBlurDrawable); 更多以上所讲的都是实现的一个思路，虽然效果和小清新搭不上关系哈，但是配了几张小清新的图片还是让我们的程序员生活增添一丝精彩。其实大家实现了基础效果之后，还可以深挖更多辅助功能，例如不同的切换效果，支持横屏，动态修改滑动速度等，相信这个过程可以让你收获良多。 Github：Recyclerview-Gallery","categories":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/学习/"}],"tags":[{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://yoursite.com/tags/RecyclerView/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/学习/"}]},{"title":"Android优化方案之--Fragment的懒加载实现","slug":"Android优化方案之--Fragment的懒加载实现","date":"2017-08-24T08:56:29.000Z","updated":"2018-01-11T10:32:04.667Z","comments":true,"path":"2017/08/24/Android优化方案之--Fragment的懒加载实现/","link":"","permalink":"http://yoursite.com/2017/08/24/Android优化方案之--Fragment的懒加载实现/","excerpt":"","text":"一、背景在Android应用中，ViewPager是我们不可避免使用的一个控件，因为它可以使我们在占用较少空间的同时，增强内容的丰富性，同时以其内部流淌着Google的血液，所以它几乎成了每一个App的标配控件。但是，假如ViewPager的每一个Fragment都需要通过网络拉取数据加载，而ViewPager是默认加载前两项的，所以在很容易造成网络丢包或者网络堵塞等问题，所以Fragment使用懒加载是非常有必要的。 举个栗子： 如上图所示，我们有两个大的Tab：人物和风景。而人物Tab下有三个Tab：美女、帅哥、萌娃三个Tab，风景Tab下有：北京、香港、上海三个Tab。假如当App刚启动时，执行的生命周期如下： 我们可以看到，App会默认加载美女和帅哥两个Fragment，并且它们的生命周期都执行到onStar（）方法，同时加载两个Fragment，假如我们在Fragment加载的时候拉取网络数据，那么就会造成如上所说的网络丢包或者网络堵塞等问题，所以我们为了避免这个问题，就需要实现Fragment的懒加载，当我们对Fragment可见的时候，再进行网络加载数据。 二、实现Fragment懒加载针对背景讨论的问题，我们最终要实现的目标就是，当Fragment对我们可见时，我们才进行网络加载，然后再解析数据，更新UI。针对上面的Demo，我们需要做到如下效果： 要实现起来其实也并不复杂，在Fragment中有一个setUserVisibleHint这个方法，而且这个方法是优于onCreate()方法的，所以也可以作为Fragment的一个生命周期来看待，它会通过isVisibleToUser告诉我们当前Fragment我们是否可见，我们可以在可见的时候再进行网络加载。1public void setUserVisibleHint(boolean isVisibleToUser) 当我们在setUserVisibleHint方法中进行Log输出时，我们可以看到： 只有可见时，我们isVisibleToUser为true，否则为false。所以我们可以重写setUserVisibleHint方法，然后在可见时进行网络加载数据： 123456789@Overridepublic void setUserVisibleHint(boolean isVisibleToUser) &#123; Log.d(&quot;TAG&quot;, mTagName + &quot; setUserVisibleHint() --&gt; isVisibleToUser = &quot; + isVisibleToUser); if (isVisibleToUser) &#123; pullData(); &#125; super.setUserVisibleHint(isVisibleToUser);&#125; 三、根据实际用途使用懒加载由第二部分我们可以知道，setUserVisibleHint(boolean isVisibleToUser)方法是比onCreate更早调用的，但是我们一般在加载数据时，都会在数据加载完成时进行UI更新，所以这就有了一个问题，假如拉取数据是秒回，但是我们还没有进行UI绑定，或者是Adapter初始化等，那么我们就无法更新UI了，所以Fragment给我们提供了另一个方法getUserVisibleHint()，它就是用来判断当前Fragment是否可见，所以我们就可以在一系列变量初始化完成后再判断是否可见，若可见再进行数据拉取： 123456789101112@Overridepublic void onStart() &#123; super.onStart(); Log.d(&quot;TAG&quot;, mTagName + &quot; onStart()&quot;); ... if(getUserVisibleHint()) &#123; pullData(); &#125;&#125; 当然，如果你的网络请求并不需要涉及UI更新，那么就可以直接在setUserVisibleHint(boolean isVisibleToUser)里操作，所以最终还是要根据各自的实际用途来使用。 最后，附上懒加载的Demo：Github/LazyFragment","categories":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/学习/"}],"tags":[{"name":"Fragment优化","slug":"Fragment优化","permalink":"http://yoursite.com/tags/Fragment优化/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/学习/"}]},{"title":"AdPlayBanner：功能丰富、一键式使用的图片轮播插件","slug":"AdPlayBanner：功能丰富、一键式使用的图片轮播插件","date":"2017-07-03T16:00:00.000Z","updated":"2018-01-11T09:44:28.690Z","comments":true,"path":"2017/07/04/AdPlayBanner：功能丰富、一键式使用的图片轮播插件/","link":"","permalink":"http://yoursite.com/2017/07/04/AdPlayBanner：功能丰富、一键式使用的图片轮播插件/","excerpt":"","text":"AdPlayBannerAdPlayBanner是一个Android平台基于ViewPager实现的轮播图插件，主要用以自动或者手动地播放轮播图，提供了Fresco、Picasso、Glide等图片加载方式供用户使用，以及多种图片切换动画，设置轮播时间，设置数据源顺序，提供不同分页指示器等功能，实现了一键式、灵活式的控件使用方式。下面是效果图： 目前AdPlayBanner已经开源到了Github上面，大家可以在Github上面查看本控件的Demo，或者直接使用。 Github地址为：https://github.com/ryanlijianchang/AdPlayBanner 一、使用方法1.添加依赖首先，在项目级别的build.gradle文件添加依赖： allprojects { repositories { ... maven { url &apos;https://jitpack.io&apos; } } } 然后，在模块目录下的build.gradle文件添加依赖： dependencies { compile &apos;com.github.ryanlijianchang:AdPlayBanner:v0.2&apos; } 2.在布局文件中添加控件在布局文件中添加AdPlayBanner控件，根据自己的需要设置高度，注意，控件需要在一个布局（可以是LinearLayout，RelativeLayout，FrameLayout等）之内。 &lt;com.ryane.banner_lib.AdPlayBanner android:id=&quot;@+id/game_banner&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; /&gt; 3.在Activity中绑定控件mAdPlayBanner = (AdPlayBanner) findViewById(R.id.game_banner); 4.添加网络权限由于加载的是网络图片，所以需要在Manifests文件中添加网络请求权限 &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; 5.初始化Fresco默认使用Fresco加载图片，所以按照Fresco官方做法，需要在Application创建时初始化Fresco，常规做法如下： (1) 创建MyApplication类继承Application，然后在onCreate()方法中初始化Fresco： public class MyApplication extends Application { @Override public void onCreate() { super.onCreate(); Fresco.initialize(this); } } (2) 在Manifests文件中标签中增加 android:name=&quot;你的类名&quot;: &lt;application android:name=&quot;.MyApplication&quot; ...&gt; ... &lt;/application&gt; 当然，如果你不使用Fresco加载，以上步骤可以跳过。 6.一键式使用AdPlayBanner使用了Builder设计模式，所以可以通过一键式写法来直接装载AdPlayBanner，当然也可以使用常规写法。在使用之前需要先设置数据源，使用ArrayList来封装数据，而AdPageInfo是一个封装好的Bean类，封装如下： public class AdPageInfo implements Parcelable { public String title; // 广告标题 public String picUrl; // 广告图片url public String clickUlr; // 图片点击url public int order; // 顺序 } 在设置完数据源mDatas之后，使用Builder模式写法，一句话就可以使用AdPlayBanner了。注意，setUp()方法必须在调用完所有API之后，最后调用： mAdPlayBanner.setInfoList(mDatas).setUp(); 当然，你也可以使用常规写法： mAdPlayBanner.setInfoList(mDatas); mAdPlayBanner.setUp(); 7.关闭AdPlayBanner在显示AdPlayBanner的页面生命周期到达onDestroy()时，建议调用mAdPlayBanner.stop()方法结束AdPlayBanner，避免内存泄漏。 二、功能介绍1.自定义数据顺序在调用setUp()方法之前，我们需要设置数据源，每一页的数据使用AdPageInfo来封装，它里面就有一个int型变量order,我们通过给每一个AdPageInfo赋值order，AdPlayBanner就会自动按照order的大小来排序，如： 我们封装了三个数据到ArrayList里面，按顺序是图片1-&gt;图片2-&gt;图片3 List&lt;AdPageInfo&gt; mDatas = new ArrayList&lt;&gt;(); AdPageInfo info1 = new AdPageInfo(&quot;图片1&quot;, &quot;http://osjnd854m.bkt.clouddn.com/pic1_meitu_1.jpg&quot;, &quot;链接1&quot;, 3); AdPageInfo info2 = new AdPageInfo(&quot;图片2&quot;, &quot;http://osjnd854m.bkt.clouddn.com/pic1_meitu_2.jpg&quot;, &quot;链接2&quot;, 2); AdPageInfo info3 = new AdPageInfo(&quot;图片3&quot;, &quot;http://osjnd854m.bkt.clouddn.com/pic1_meitu_3.jpg&quot;, &quot;链接3&quot;, 1); mDatas.add(info1); mDatas.add(info2); mDatas.add(info3); 装载之后运行，可见轮播顺序是按照order的顺序来播放： 2.无限循环轮播很多轮播插件没有实现无限循环轮播这个功能, 而在AdPlayBanner上得到了实现，如下图可见，当我们无限循环滑动时，插件仍能正常运行： 3.支持三种图片加载方式目前比较主流的Fresco、Picasso、Glide三种图片加载方式在AdPlayBanner中都支持，至于三者的区别我就不赘述了，默认是使用Fresco方式加载，具体调用方法setImageLoadType(ImageLoaderType type)，只需要将传入数据设置为：FRESCO、GLIDE、PICASSO其中一种即可，同样，也是可以通过代码一键式使用，例如使用Glide方式加载（其他加载方式使用类似），使用方法如下： mAdPlayBanner .setInfoList((ArrayList&lt;AdPageInfo&gt;) mDatas) .setImageLoadType(Glide) // 设置Glide类型的图片加载方式 .setUp(); 4.支持多种ScaleType在AdPlayBanner中，可以根据用户需要设置图片的ScaleType，具体效果和ImageView的ScaleType一致，默认是使用FIT_XY，但是在AdPlayBanner中比ImageView少了一种MATRIX类型，在AdPlayBanner中具体支持的ScaleType有如下：FIT_XY、FIT_START、FIT_CENTER、FIT_END、CENTER、CENTER_CROP、CENTER_INSIDE其中，具体调用方法setImageViewScaleType(ScaleType scaleType)，只需要将具体的ScaleType传入即可，同样，也是可以通过代码一键式使用，例如设置ScaleType为FIT_START（其他类似），使用方法如下： mAdPlayBanner .setInfoList((ArrayList&lt;AdPageInfo&gt;) mDatas) .setImageViewScaleType(FIT_START) // 设置FIT_START类型的ScaleType .setUp(); 5.支持不同页码指示器在AdPlayBanner中，提供了数字型、点型和空型页码指示器，用户可以通过调用setIndicatorType(IndicatorType type)，传入NONE_INDICATOR，NUMBER_INDICATOR，POINT_INDICATOR其中一种，即可显示对应的页码指示器，三种页码指示器对应效果如下： (1) NONE_INDICATOR：空型页码指示器 (2) NUMBER_INDICATOR：数字页码指示器 (3) POINT_INDICATOR：点型页码指示器 使用方法也是非常简单，如我需要使用数字型页码指示器，使用方法如下： mAdPlayBanner .setInfoList((ArrayList&lt;AdPageInfo&gt;) mDatas) .setIndicatorType(NUMBER_INDICATOR) //使用数字页码指示器 .setUp(); 此外，你也可以调用setNumberViewColor(int normalColor, int selectedColor, int numberColor)来修改数字型页码指示器的样式，normalColor为数字没选中时的背景颜色，selectedColor为数字选中时的背景颜色，numberColor为数字的字体颜色，例如我通过调用这个方法，把三个颜色都改变掉（注意：传入int型颜色必须ARGB8888的颜色类型，或者通过资源文件定义颜色再获取才有效），使用方法如下： mAdPlayBanner .setInfoList((ArrayList&lt;AdPageInfo&gt;) mDatas) .setIndicatorType(NUMBER_INDICATOR) //使用数字页码指示器 .setNumberViewColor(0xff00ffff, 0xffff3333, 0xff0000ff) .setUp(); 得到如下效果： 6.添加灵活性标题在AdPlayBanner中，只需要调用addTitleView(TitleView mTitleView)，就可以插入标题了，并且该标题的灵活性很强，可以根据用户需要修改标题的背景、位置、字体大小、padding、magin等，先上一个提供的默认效果： 由于是使用了默认的效果，所以用法也是非常简单： mAdPlayBanner .setInfoList((ArrayList&lt;AdPageInfo&gt;) mDatas) .setIndicatorType(POINT_INDICATOR) //使用数字页码指示器 .addTitleView(TitleView.getDefaultTitleView(getApplicationContext())) // 使用默认标题 .setUp(); 我们可以看到我们通过调用addTitleView(TitleView mTitleView)，传入一个TitleView即可以生成标题，而上面是调用了AdPlayBanner提供的一个默认标题，当然，我们也说了这个标题的灵活性很强，就是我们可以设置TitleView的属性，我们来看一下TitleView提供了哪些API： TitleView setTitleColor(int color)：设置标题字体颜色，传入color必须ARGB8888的颜色类型，或者通过资源文件定义颜色再获取才有效。 setPosition(Gravity gravity)：设置标题在AdPlayBanner中的位置，有PARENT_TOP,PARENT_BOTTOM,PARENT_CENTER三个取值，分别位于父布局顶部，父布局底部，父布局中间。 setViewBackground(int color)：设置标题的背景颜色，传入int型颜色必须ARGB8888的颜色类型，或者通过资源文件定义颜色再获取才有效。 TitleView setTitleSize(int size)：设置标题的字体大小，单位是sp。 setTitleMargin(int left, int top, int right, int bottom)：设置标题的四个方向margin值，单位是dp。 setTitlePadding(int left, int top, int right, int bottom)：设置标题的四个方向padding值，单位是dp。 同样，TitleView也是支持Builder模式的写法，例如我自定义一个TitleVIew并加到AdPlayBanner中，使用方法如下： mAdPlayBanner .setInfoList((ArrayList&lt;AdPageInfo&gt;) mDatas) .setIndicatorType(POINT_INDICATOR) // 使用数字页码指示器 .addTitleView(new TitleView(getApplicationContext()) // 创建新的TitleView .setPosition(PARENT_TOP) .setTitleColor(0xffffffff) // 设置字体颜色 .setViewBackground(0x9944ff18) // 设置标题背景颜色 .setTitleSize(18) // 设置字体大小 .setTitleMargin(0,0,2,0) // 设置margin值 .setTitlePadding(2,2,2,2)) // 设置padding值 .setUp(); 效果如下： 7.支持多样式切换动画由于AdPlayBanner是基于ViewPager实现的，所以AdPlayBanner和ViewPager一样，同样支持自定义的切换动画，只需要通过调用setPageTransfromer(ViewPager.PageTransformer transformer)方法，传入一个PageTransformer，即可改变它的切换样式，AdPlayBanner中提供了三种现成的切换方式： FadeInFadeOutTransformer：淡入淡出效果 RotateDownTransformer：旋转效果 ZoomOutPageTransformer： 空间切换效果 使用起来也是非常简单，例如使用ZoomOutPageTransformer切换效果： mAdPlayBanner .setInfoList((ArrayList&lt;AdPageInfo&gt;) mDatas) .setIndicatorType(POINT_INDICATOR) // 使用数字页码指示器 .setBannerBackground(0xff000000) // 设置背景颜色 .setPageTransfromer(new ZoomOutPageTransformer()) // 设置切换效果 .setUp(); 当然，你也可以自定义一个transformer实现ViewPager.PageTransformer接口，并重写transformPage(View view, float position)方法即可实现自定义的切换效果。 8.设置是否自动轮播通过调用setAutoPlay(boolean autoPlay),传入boolean值控制是否自动播放的开关，传入true为自动，传入false为手动。 9.设置自动滑动间隔时间通过调用setInterval(int interval)，传入int型的时间（单位ms），即可改变AdPlayBanner自动轮播时的切换时间。 10.设置点击事件监听器AdPlayBanner支持点击事件监听，通过调用setOnPageClickListener(OnPageClickListener l)，传入OnPageClickListener，即可完成AdPlayBanner的点击监听，使用方法非常简单： mAdPlayBanner .setInfoList((ArrayList&lt;AdPageInfo&gt;) mDatas) .setIndicatorType(POINT_INDICATOR) // 使用数字页码指示器 .setOnPageClickListener(new AdPlayBanner.OnPageClickListener() { @Override public void onPageClick(AdPageInfo info, int postion) { // 点击操作 } }) .setUp(); 11.关闭AdPlayBanner在离开显示AdPlayBanner的页面时，建议调用stop()方法，避免内存泄漏。 三、APIAdPlayBanner：实现轮播效果的控件 AdPlayBanner 解释 备注 addTitleView(TitleView mTitleView) 添加一个TitleView 可以通过TitleView.getDefaultTitleView(Context context)来使用默认的TitleView或者通过new Title()的方式传入 setBannerBackground(int color) 设置AdPlayBanner的背景颜色 传入color必须ARGB8888的颜色类型，或者通过资源文件定义颜色再获取才有效 setIndicatorType(IndicatorType type) 设置页码指示器类型 传入NONE_INDICATOR，NUMBER_INDICATOR，POINT_INDICATOR其中一种 setInterval(int interval) 设置自动轮播时的切换时间 单位ms setImageLoadType(ImageLoaderType type) 设置图片加载方式 传入FRESCO、GLIDE、PICASSO其中一种 setPageTransfromer(ViewPager.PageTransformer transformer) 设置切换动画，如果不设置动画，设置为null 提供了FadeInFadeOutTransformer，RotateDownTransformer，ZoomOutPageTransformer三种，也可以传入自定义的TransFormer setNumberViewColor(int normalColor, int selectedColor, int numberColor) 设置数字页码的颜色 normalColor 数字正常背景颜色，selectedColor 数字选中背景颜色，numberColor 数字字体颜色 setOnPageClickListener(OnPageClickListener l) 设置事件点击监听器 传入一个OnPageClickListener setImageViewScaleType(ScaleType scaleType) 设置图片的ScaleType 传入FIT_XY、FIT_START、FIT_CENTER、FIT_END、CENTER、CENTER_CROP、CENTER_INSIDE其中一种 setAutoPlay(boolean autoPlay) 设置是否自动播放 默认为true 自动播放，传入false为手动 setInfoList(ArrayList pageInfos) 设置Banner的数据源 传入必须为AdPageInfo类型的ArrayList setUp() 装载AdPlayBanner 必须在以上所有方法调用完之后才能调用 stop() 结束AdPlayBanner 在离开显示AdPlayBanner页面时调用，避免内存泄漏 TitleView ： 标题控件 TitleView 解释 备注 getDefaultTitleView(Context context) 获取一个默认的TitleView 传入一个Context setTitleSize(int size) 设置字体大小 单位sp setTitleColor(int color) 设置字体颜色 传入color必须ARGB8888的颜色类型，或者通过资源文件定义颜色再获取才有效 setViewBackground(int color) 设置标题背景 传入color必须ARGB8888的颜色类型，或者通过资源文件定义颜色再获取才有效 setPosition(Gravity gravity) 设置标题在Banner的位置 只能PARENT_TOP,PARENT_BOTTOM,PARENT_CENTER其中一个值 setTitleMargin(int left, int top, int right, int bottom) 设置标题的margin值 单位dp setTitlePadding(int left, int top, int right, int bottom) 设置标题的padding值 单位dp AdPageInfo：AdPlayView指定的数据源 AdPageInfo 解释 备注 AdPageInfo(String title, String picUrl, String clickUlr, int order) 构造方法 void setTitle(String title) 设置标题 String getTitle() 获取标题 void setPicUrl(String picUrl) 设置图片源地址 String getPicUrl() 获取图片链接 void setClickUlr(String clickUlr) 设置点击事件地址 String getClickUlr() 获取点击事件链接 void setOrder(int order) 设置排序的优先级 设置了order，AdPlayBanner会根据order的大小由小到大排序 int getOrder() 获取排序优先级 四、版本特性v0.1 基本框架搭建完成； V0.2 支持定义数据顺序； 无限循环轮播； 支持Fresco、Glide、Picasso三种图片加载方式； 支持多种ScaleType； 支持点型、数字型、空型页码指示器；支持修改数字型页码器的样式； 支持灵活性标题；支持修改标题的位置、字体大小、颜色、边距值等属性； 支持多样式切换动画； 支持设置自动轮播开关； 自定义自动滑动间隔时间； 提供点击事件监听器； 支持修改AdPlayBanner的背景颜色； V0.3 修复了静态变量造成的内存泄漏问题; 提供手动结束Banner播放的接口; 五、 Demo如果大家在使用在仍然有问题，可以通过下载Demo来学习，当然，大家更可以通过查看源代码来学习如何自定义一个轮播控件。 六、后记AdPlayBanner作为作者的第一个开源控件，作者也是非常用心认真地完成，这个过程也学习到很多东西，可能其中会遇到很多错误，所以希望大家可以多多包涵，然后把错误提到Issues里面，作者会在看到的第一时间进行修正。在后面的时间里，作者也会将更多的特性加到这个控件里面，所以希望大家可以加个star，以作为对作者的小小鼓励。 当然，如果你想第一时间联系到作者，不妨尝试以下联系方式： Email：liji.anchang@163.com CSDN：http://blog.csdn.net/ljcitworld Github：https://github.com/ryanlijianchang","categories":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/学习/"}],"tags":[{"name":"图片轮播","slug":"图片轮播","permalink":"http://yoursite.com/tags/图片轮播/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/学习/"}]},{"title":"Android基础夯实--重温动画（五）之属性动画 ObjectAnimator详解","slug":"Android基础夯实--重温动画（五）之属性动画 ObjectAnimator详解","date":"2017-04-24T16:00:00.000Z","updated":"2018-01-11T10:21:37.931Z","comments":true,"path":"2017/04/25/Android基础夯实--重温动画（五）之属性动画 ObjectAnimator详解/","link":"","permalink":"http://yoursite.com/2017/04/25/Android基础夯实--重温动画（五）之属性动画 ObjectAnimator详解/","excerpt":"","text":"只有一种真正的英雄主义 一、摘要ObjectAnimator是ValueAnimator的子类，它和ValueAnimator一样，同样具有计算属性值的功能，但对比ValueAnimator，它会更加容易使用，因为它不再需要设置监听器来监听值的变化，因为这个工程对于ObjectAnimator来说，是自动的。这篇文章主要通过详细讲解ObejctAniamtior，加深大家对属性动画的认识，让我们对于动画的技巧掌握得更扎实。 如果你想了解更权威的解释，可以查看官方文档：Property Animation。 本文主要对ValueAnimator做介绍，如果大家有兴趣，可以继续阅读本动画系列其他相关文章，作者也在不断更新完善相关内容，希望大家可以指出有误之处。 二、 概述在上节我们知道了在属性动画中，ValueAnimator是通过监听值的变化，然后实现控件的动画播放。在代码过程中，是通过设置初始值、结束值和动画时间，然后通过加速器返回当前的进度的，再经过Evaluator根据进度计算出具体的值，然后我们在监听器里面不断监听拿到这个值，然后修改控件的属性值，从而实现动画。 ObjectAnimator作为ValueAnimator的子类，所以ValueAnimator的很多方法，在ObjectAnimator中也能使用，但是ObjectAnimator覆写了父类的几个方法，如ofInt()，ofFloat()，ofArgb()等。它和ValueAnimator同样也是首先设置初始值、结束值和动画时长，但是同时也绑定了目标控件和属性然后通过加速器返回当前的进度的，再经过Evaluator根据进度计算出具体的值，最后根据属性拼接set函数并反射调用，并将当前值作为参数传入，实现动画。 对比这两个Animator，ObjectAnimator是对ValueAnimator的再封装，它的封装帮助我们避免了使用Listener的麻烦，更加精简了代码，使开发者可以更加专注动画的逻辑代码。 2.1 差异以下通过Demo来对比ObjectAnimator和ValueAnimator的区别，我们同样使用ObjectAnimator和ValueAnimator实现同样的效果，控件水平方向上的不断左右移动，最后返回原点（如下图）。 通过上一节的学习，我们可以轻松写出ValueAnimator实现的代码： 123456789ValueAnimator animator = ValueAnimator.ofFloat(0, 300, -100, 200, -50, 0);animator.setDuration(2000);animator.start();animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; mBinding.image.setTranslationX((Float) animation.getAnimatedValue()); &#125;&#125;); 在ObjectAnimator中，我们可以用更简单的代码来实现： 123ObjectAnimator animator = ObjectAnimator.ofFloat(mBinding.image, &quot;translationX&quot;, 0, 300, -100, 200, -50, 0);animator.setDuration(2000);animator.start(); 通过对比，我们可以看到，ObjectAnimator在实现动画上的代码上会更加简洁，但是实现的效果都是一样的，之所以是这样，是因为ObjectAnimator覆写了ValueAnimator 的ofFloat方法，并对其进行了封装。所以，我们看到ObjectAnimator实现代码上都减少了Listener代码的编写。 大家第一次看到ObjectAnimator可能看到代码比较陌生，上面的一段代码什么意思呢？首先我们看到第一个参数，就是我们动画的目标控件，也就是这个动画要让哪个控件来实现，我这里是DATABinding的一个写法，其实就是我们findViewById得到的一个view，非常的简单；第二个参数是动画要实现的效果，我这里是translationX，即水平x方向上的位移；第三个参数为可变参数，即动画变化过程的系列值，跟ValueAnimator是一样的意思。 2.2 propertyName在2.1的介绍过后，大家可能还会有疑问，对于上面ofFloat的第二个参数是一个字符串常量，这个字符串常量我们是怎么获取的呢？其实，在ObejctAnimator中，无论ofFloat，ofInt，ofArgb等方法，都有一个叫做propertyName的参数，也就是我们上面对应的第二个参数，这个参数是一个字符串，之所以动画会实现该字符串的效果是因为ObjectAnimator通过反射机制，找到了ImageView中的setTranslationX()这个方法，然后每个十几ms就调用这个方法，并把我们的变化的值传到里面去，从而实现动画效果。 所以到这里大家可以知道，当我们需要用ObjectAnimator实现一个控件的动画效果时，我们首先需要做的就是在这个控件中找到对应的setXXX()驼峰式写法的方法，只有控件拥有相应的setXXX()方法， 我们传入的propertyName参数才起到作用。那么这时候就有同学会问，类似Demo中的“translationX”，它对应的方法是setTranslationX()，那我们应该传入“TranslationX”还是“translationX”，其实都是可以的，因为它内部封装在使用反射机制调用方法时，涵盖了两种写法，所以第一个字母可以大小写，但是后面的字母必须全部对应大小写。 其次还要同学会疑问，我们怎么知道在实例化ObjectAnimator时应该通过ofFloat还是ofInt还是其他呢？其实跟我们的ValueAnimator一样，我们调用哪个方法来实例化都是要考虑我们要改变的控件哪个属性的。例如，我们上面的例子是改变水平方向上的位移，那么ObjectAnimator最终是调用控件的setTranslationX(float translationX)，我们可以看到传入参数是float型，那么毫无疑问，我们这里需要使用ofFloat了，其它以此类推。下面给大家举例一些常用的propertyName。 2.2.1 ScaleView中关于伸缩变化(Scale)有以下两个方法： public void setScaleX(float scaleX)：X方向上伸缩。 public void setScaleY(float scaleY)：Y方向上伸缩。 所以对应代码为： 1234ObjectAnimator animator = ObjectAnimator.ofFloat(mBinding.image, &quot;scaleX&quot;, 0f, 1.5f, 2f, 1.5f, 0f, 0.5f, 0.2f, 1f);mBinding.image.setScaleType(ImageView.ScaleType.CENTER_CROP);animator.setDuration(2000);animator.start(); 12345View view = new View(MyObjectAnimator.this);ObjectAnimator animator = ObjectAnimator.ofFloat(mBinding.image, &quot;scaleY&quot;, 0f, 1.5f, 2f, 1.5f, 0f, 0.5f, 0.2f, 1f);animator.setDuration(2000);mBinding.image.setScaleType(ImageView.ScaleType.CENTER_CROP);animator.start(); 2.2.2 TranslationView中关于位置变化(Translation)有以下两个方法： public void setTranslationX(float translationX)：X轴上位移。 public void setTranslationY(float translationY)：Y轴上位移。 public void setTranslationZ(float translationZ)：设置阴影。 所以对应代码为： 1234ObjectAnimator animator = ObjectAnimator.ofFloat(mBinding.image, &quot;translationX&quot;, 0, 100, -100, 0);mBinding.image.setScaleType(ImageView.ScaleType.CENTER_CROP);animator.setDuration(2000);animator.start(); 1234ObjectAnimator animator = ObjectAnimator.ofFloat(mBinding.image, &quot;translationY&quot;, 0, 100, -100, 0);animator.setDuration(2000);mBinding.image.setScaleType(ImageView.ScaleType.CENTER_CROP);animator.start(); 2.2.3 AlphaView中关于透明度变化(Alpha)有以下方法： public void setAlpha(float alpha); 所以对应代码为： 1234ObjectAnimator animator = ObjectAnimator.ofFloat(mBinding.image, &quot;alpha&quot;, 0, 0.5f, 1.0f);mBinding.image.setScaleType(ImageView.ScaleType.CENTER_CROP);animator.setDuration(2000);animator.start(); 2.2.4 RotationView中关于角度变化(Rotation)有以下方法： public void setRotation(float rotation)：关于Z轴旋转。 public void setRotationX(float rotationX)：关于X轴旋转。 public void setRotationY(float rotationY)：关于Y轴旋转。 所以对应代码为： 1234ObjectAnimator animator = ObjectAnimator.ofFloat(mBinding.image, &quot;rotation&quot;, 0, 180, 0, -180, 0);mBinding.image.setScaleType(ImageView.ScaleType.CENTER_CROP);animator.setDuration(3000);animator.start(); 1234ObjectAnimator animator = ObjectAnimator.ofFloat(mBinding.image, &quot;rotationX&quot;, 0, 180, 0, -180, 0);animator.setDuration(3000);mBinding.image.setScaleType(ImageView.ScaleType.CENTER_CROP);animator.start(); 1234ObjectAnimator animator = ObjectAnimator.ofFloat(mBinding.image, &quot;rotationY&quot;, 0, 180, 0, -180, 0);animator.setDuration(3000);mBinding.image.setScaleType(ImageView.ScaleType.CENTER_CROP);animator.start(); 2.2.5 图片变化View中关于图片的其中一个方法是setBackgroundResource，同样我们也可以通过ObjectAnimator来实现一个图片变化的效果： public void setBackgroundResource(@DrawableRes int resid) 对应代码为： 123ObjectAnimator animator = ObjectAnimator.ofInt(mBinding.image, &quot;backgroundResource&quot;, R.drawable.a1, R.drawable.a2, R.drawable.a3);animator.setDuration(2000);animator.start(); 其实还有很多set方法可以可以实现动画效果，这里就不再一一列举，大家有兴趣可以自己去深入研究，你会发现ObjectAnimator可以非常简单快捷地实现动画效果。 2.3 实例化ObjectAnimator方法在ValueAnimator中，我们知道实例化并不是通过new一个对象出来，而是通过ofInt，ofFloat，ofObject等方法。在ObjectAnimator中同样如此，因为ofInt，ofFloat，ofObject等方法的内部帮我们封装了实例化过程，所以我们可以直接调用来拿到一个实例化的对象。在ObjectAnimator中，大概有以下几种实例化方法： 2.3.1 ofInt()通过ofInt()来实例化对象，那么属性值必须为int型，通常我们通过ofInt可以实现很多动画，例如实现颜色渐变等；ofInt()也有几个重载函数，这里介绍其中一个： ofInt(Object target, String propertyName, int… values)：对目标对象T的property属性值进行改变。 例如颜色值的变化。 1234ObjectAnimator animator = ObjectAnimator.ofInt(mBinding.image, &quot;backgroundColor&quot;, 0xffff00ff, 0xffffff00, 0xffff00ff);animator.setEvaluator(new ArgbEvaluator());animator.setDuration(4000);animator.start(); 2.3.2 ofFloat()ofFloat()来实例化对象，那么属性值必须为float型，通常我们通过ofFloat可以实现很多动画，例如实现位置变化等；ofFloat()也有几个重载函数，这里介绍其中一个： ObjectAnimator ofFloat (Object target, String xPropertyName, String yPropertyName, Path path)：：对目标对象T的property属性值进行改变。 例如实现一个贝塞尔曲线： 12345Path path = new Path();path.quadTo(800, 200, 800, 800);ObjectAnimator animator = ObjectAnimator.ofFloat(mBinding.image, &quot;x&quot;, &quot;y&quot;, path);animator.setDuration(4000);animator.start(); 2.3.3 ofArgb()我们在ValueAnimator中已经提到了ofArgb()可以帮助我们实现颜色的渐变效果，这里同样是可以通过ofArgb()来实现动画效果。上面我们已经在ofInt里面实现了颜色渐变，但是代码稍多，所以Google在API LEVEL 21之后增加了这个方法ofArgb()。通过这个方法我们更容易地实现颜色演变，因为它里面封装了对ArgbEvaluator的使用，实现2.3.1的效果，大家可以对比一下代码： 123ObjectAnimator animator = ObjectAnimator.ofArgb(mBinding.image, &quot;BackgroundColor&quot;, 0xffff00ff, 0xffffff00, 0xffff00ff);animator.setDuration(4000);animator.start(); 2.3.4 ofPropertyValuesHolder()认真的同学都会发现，在ValueAnimator和ObjectAnimator中，都有一个实例化方法，就是ofPropertyValuesHolder()方法，由于在ObjectAnimator中使用更为广泛，所以这里以ObjectAnimator的ofPropertyValuesHolder为例子，当大家懂了之后，那么大家对ValueAnimator的ofPropertyValuesHolder也应该理解了。 在ObjectAnimator中，我们可以通过 ObjectAnimator ofPropertyValuesHolder (Object target, PropertyValuesHolder... values) 来实例化一个ObjectAnimator。 我们可以看到，它和我们其他的实例化方法差不多，都需要设置一个target（目标控件），还有一组PropertyValuesHolder类型的值，但是不需要设置属性，target我们知道了，是要实现动画的控件，那么PropertyValuesHolder是什么呢？我们来看一下官方文档： This class holds information about a property and the values that that property should take on during an animation. PropertyValuesHolder objects can be used to create animations with ValueAnimator or ObjectAnimator that operate on several different properties in parallel. 什么意思呢？ 这是一个包含一个属性信息的类，并且它的值应该用到一个动画里面。PropertyValuesHolder对象可以配合ValueAnimator和ObjectAnimator来实现不同属性的并行的动画。 听起来有点别扭，也就是说，当我们需要实现一个包含多种属性的同时播放的动画时，我们就可以使用ofPropertyValuesHolder来实例化一个Animator，当然，拥有一个属性时也是可以的，为什么这么说？ofFloat()的内部实现其实就是将传进来的参数封装成PropertyValuesHolder实例来保存动画状态。所以可见PropertyValuesHolder是多么有用了吧。 在PropertyValuesHolder这个类里面，同样也有ofInt()，ofFloat()，ofKeyframe()等方法来实例化，举个例子： 代码也非常简单： 12345678PropertyValuesHolder rotationHolder = PropertyValuesHolder.ofFloat(&quot;Rotation&quot;, 90, -90, 45, -45, 60, -60);PropertyValuesHolder colorHolder = PropertyValuesHolder.ofInt(&quot;BackgroundColor&quot;, 0xff55aa11, 0xff115633, 0xff123344, 0xffaabbcc);PropertyValuesHolder scaleXHolder = PropertyValuesHolder.ofFloat(&quot;ScaleX&quot;, 1f, 1.1f, 1.2f, 1.5f, 1.8f, 1.5f, 1.2f, 1.1f, 1);PropertyValuesHolder scaleYHolder = PropertyValuesHolder.ofFloat(&quot;ScaleY&quot;, 1f, 1.1f, 1.2f, 1.5f, 1.8f, 1.5f, 1.2f, 1.1f, 1);ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(mBinding.image, rotationHolder, colorHolder, scaleXHolder, scaleYHolder);animator.setDuration(3500);animator.setInterpolator(new AccelerateInterpolator());animator.start(); 通过代码我们可以知道，通过ofPropertyValuesHolder来实例化，其实就是将不同动画效果分配到一个个PropertyValuesHolder中去，然后把多个不同的PropertyValuesHolder对象在初始化时传入，最终实现多个效果并行播放。 2.3.4 其他实例化方法在ObjectAnimator中提供了非常丰富的实例化方法，除了以上三个之外，在API LEVEL 21之后，Google推出了更多的实例化方法，例如： ofMultiFloat() ofMultiInt() ofObject() ofPropertyValuesHolder() 在上面三个(2.3.1-2.3.3)不足以解决我们需求的时候，我们可以到官方文档参考这三个比较新的实例化方法，它们也是为了简化操作而进行了更高度的封装，所以这也有助于帮助我们用更少的代码来实现动画。 总结ObjectAnimator作为ValueAnimator的子类，在代码上对ValueAnimator进行了进一步的封装，使我们在日常使用中更加简单，但是正是因为封装，使得我们在一些特殊情况下使用ObjectAnimator使用上还是有一定的局限性，所以在大家掌握了ValueAnimator和ObjectAnimator的基本使用后，还需要自己通过写小Demo来加深和进阶使用，这样在我们用到时方能得心应手。","categories":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/学习/"}],"tags":[{"name":"动画","slug":"动画","permalink":"http://yoursite.com/tags/动画/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/学习/"}]},{"title":"Android基础夯实--重温动画（四）之属性动画 ValueAnimator详解","slug":"Android基础夯实--重温动画（四）之属性动画 ValueAnimator详解","date":"2017-04-09T16:00:00.000Z","updated":"2018-01-11T10:15:36.354Z","comments":true,"path":"2017/04/10/Android基础夯实--重温动画（四）之属性动画 ValueAnimator详解/","link":"","permalink":"http://yoursite.com/2017/04/10/Android基础夯实--重温动画（四）之属性动画 ValueAnimator详解/","excerpt":"","text":"宝剑锋从磨砺出,梅花香自苦寒来；千淘万漉虽辛苦,吹尽狂沙始到金； 长风破浪会有时,直挂云帆济沧海 一、摘要Animator类作为属性动画的基类，它是一个抽象类，它提供了实现动画的基本架构，但是我们不能直接使用它，因为它只是提供了最基本的的实现动画的方法，只有让它的子类继承它并进行相应扩展之后，我们才会使用它实现动画。在属性动画中，Animator包括了ValueAnimator、ObjectAnimator和AnimatorSet三个子类，下面给大家详解ValueAnimator。 如果你想了解更权威的解释，可以查看官方文档：Property Animation。 本文主要对ValueAnimator做介绍，如果大家有兴趣，可以继续阅读本动画系列其他相关文章，作者也在不断更新完善相关内容，希望大家可以指出有误之处。 二、ValueAnimatorValueAnimator，就是针对值的，也就是说ValueAnimator不会对控件进行任何操作，而是控制值的变化，然后我们监听这个值的变化过程，自己来控制控件的变化。什么意思呢？就像我们上面1.2中的例子，使用属性动画来控制TextView的位移，我们在初始化ValueAnimator时，会设置一个初始值和结束的值，例子我用这两个值来控制TextView在y轴上的位置，然后设置监听器，监听初始值变化到结束值的过程，在不断变化过程中，通过调用TextView的layout方法来不断更新TextView的位置，从而实现位移动画。 2.1 初识ValueAnimator先上一个例子，实现图片的渐变过程： 我们都知道，在使用Tween Animation时是非常容易实现的，使用AlphaAnimation就可以实现，假如我们用属性动画的话，怎么实现呢？也是非常简单，布局代码就不贴了，看看使用ValueAnimator如何简单快捷地实现渐变动画。 12345678910111213141516// 第一步，创建一个ValueAnimator。直接调用ValueAnimator.ofFloat来初始化，设置开始值和结束值final ValueAnimator alphaAnimator = ValueAnimator.ofFloat(1, 0);// 设置变化时长alphaAnimator.setDuration(1000);alphaAnimator.start();// 第二步，ValueAnimator设置监听器alphaAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; // 我们来检查一下这个方法会调用多少次 Log.i(&quot;TAG&quot;, &quot;curValue is &quot; + animation.getAnimatedValue()); // 在ValueAnimator变化的过程中更新控件的透明度 mBinding.image.setAlpha((float)alphaAnimator.getAnimatedValue()); &#125;&#125;); 而我们在监听器内设置的Log的结果如下，我们可以看到onAnimationUpdate方法被不断地执行，输出值不断由我们设置的初始值变化到我们设置的结束值，所以这个值的变化过程正是我们需要让控件变化的过程。 通过例子，我们可以大概总结使用ValueAnimator的两个主要过程： (1). 初始化ValueAnimator，并设置初始值和结束值，还有动画的时间，然后start。 (2). 给ValueAnimator设置监听器，通过getAnimatedValue()拿到变化值，然后我们手动更新控件的变化。 2.2 深入了解ValueAnimator由于ValueAnimator里面的方法确实不少，所以我们从上面的例子入手，从常用到不常用地讲解ValueAnimator的API，毕竟只要我们掌握了最常用的知识点之后，在我们需要时再去深入了解不常用的知识点，我觉得是个最有效率的学习方式。 由上面的Demo代码的第一步我们可以看到，首先我们需要获取到一个ValueAnimator实例，按照我们的常规思维，我们都会通过new一个对象出来，以代码为例，我们是通过ofFloat方法来获取一个实例对象，那么我们的第一个疑问就是关于构造函数的，到底ValueAnimator有没有构造函数呢？如果有，为什么不通过构造函数来初始化呢？ 答案是有的，至于为什么，我们一探究竟。 2.2.1构造函数 ValueAnimator()：创建一个ValueAnimator对象。 ValueAnimator确实有它的构造函数，但是官方文档不建议我们直接使用它，因为在内部实现的时候才会用到它。之所以不需要用到它，是因为API给我们封装了一系列的的方法来获取实例对象。 2.2.2实例化对象的方法 ValueAnimator ofInt (int… values)：返回一个int型变化的ValueAnimator。 ValueAnimator ofFloat (float… values)：返回一个float型变化的ValueAnimator。 ValueAnimator ofObject (TypeEvaluator evaluator, Object… values)：返回一个object型变化的ValueAnimator。 ValueAnimator ofArgb (int… values)：返回一个颜色值变化的ValueAnimator，API LEVEL 21引入。 ValueAnimator ofPropertyValuesHolder(PropertyValuesHolder… values)：返回一个PropertyValuesHolder型变化的ValueAnimator，在ObjectAnimator再详说。 为什么我们需要通过这些方法来实例化对象呢？这是因为这些方法内部都对实例化对象进行了封装，我们以ofInt为例看一下它的内部实现，它内部其实还是通过new的方式来实例化，然后通过设置一些属性，然后返回这个ValueAnimator对象。 12345public static ValueAnimator ofInt(int... values) &#123; ValueAnimator anim = new ValueAnimator(); anim.setIntValues(values); return anim;&#125; ofArgb的使用在ValueAnimator中的ofArgb()可以帮助我们实现颜色的渐变效果，Google在API LEVEL 21之后增加了这个方法ofArgb()。通过这个方法我们更容易地实现颜色演变，通过ofArgb和ArgbEvaluator，我们可以轻松实现颜色渐变效果： 代码： 12345678910ValueAnimator animator = ValueAnimator.ofInt(0xffff00ff, 0xffffff00, 0xffff00ff);animator.setEvaluator(new ArgbEvaluator());animator.setDuration(3000);animator.start();animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; mBinding.image.setBackgroundColor((Integer) animation.getAnimatedValue()); &#125;&#125;); ofObject的使用ofObject方法是什么意思呢？我们都知道ofInt和ofFloat都是针对Int值和Float值的变化，但是，我们只能控制一个值的变化，但是当我们需要实现多值变化时，它们就不再满足我们的需求。例如我们需要同时实现位移、透明度变化等动画，这里需要设置两个属性值的变化，所以如果我们只有一个初始值是不行的，因为两个属性的初始值和结束值不一样，那么我们就可以将两个属性值封装到一个对象里面，那么初始值的object和结束值的object就可以包含两个属性不同的初始值和结束值了。 下面是一个对ValueAnimator ofObject (TypeEvaluator evaluator, Object… values)方法具体使用的小Demo，实现图片的放大和渐变过程，先看效果图： 首先我们看到ofObject的参数里面有一个TypeEvaluator和一个Object型可变参数，一般传入一个初始值和结束值，首先TypeEvaluator就是一个计算值的工具，API提供有现成的(下面详说)，也可以自己实现(这里为了给大家知道是个什么东西，就自己实现)；然后Obejct型，我们自己写一个类代替Obejct型。 因为我们有两个动画，包括放大和透明度变化，我们定义一个叫ValueObject的类，里面就包含两个属性，代码也非常简单： 123456789class ValueObject &#123; float alphaValue; //透明度的值 float scaleValue; //伸缩变化的值 public ValueObject(float alphaValue, float scaleValue) &#123; this.alphaValue = alphaValue; this.scaleValue = scaleValue; &#125;&#125; 然后，我们就需要自定义TypeEvaluator了，因为TypeEvaluator是一个接口，我们就写一个名叫MyEvaluator的类，它实现了TypeEvaluator的接口，传入我们的值类型为ValueObject，然后重写evaluate方法（TypeEvaluator接口只有这个方法需要实现）,代码也很简单： 123456789101112class MyEvaluator implements TypeEvaluator&lt;ValueObject&gt; &#123; // 属性动画封装了一个因子fraction，我们设置动画时需要setDuration(xxxx)，例如时间为1000ms，那么当到达100ms时，fraction就为0.1 // fraction也就是当前时间占总时间的百分比，startValue和endValue就是我们传入的初始值和结束值 @Override public ValueObject evaluate(float fraction, ValueObject startValue, ValueObject endValue) &#123; // 计算某个时刻的alpha值和scale值。类似速度公式Vt = V0 + at float nowAlphaValue = startValue.alphaValue + (endValue.alphaValue - startValue.alphaValue) * fraction; float nowScaleValue = startValue.scaleValue + (endValue.scaleValue - startValue.scaleValue) * fraction; return new ValueObject(nowAlphaValue, nowScaleValue); &#125;&#125; 这两个类我们都实现了，那么动画就很简单了： 123456789101112131415161718192021public void objectAnimation() &#123; // 初始alpha值为1，scale值为1 ValueObject startObjectVal = new ValueObject(1f, 1f); // 结束alpha值为0，scale值为2，相当于透明度变为0，尺寸放大到2倍 ValueObject endObjectVal = new ValueObject(0f, 2f); MyEvaluator myEvaluator = new MyEvaluator(); final ValueAnimator animator = ValueAnimator.ofObject(myEvaluator, startObjectVal, endObjectVal); animator.setDuration(3000); animator.start(); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; mBinding.image.setAlpha(((ValueObject) animation.getAnimatedValue()).alphaValue); mBinding.image.setScaleType(ImageView.ScaleType.CENTER); mBinding.image.setScaleX(((ValueObject) animation.getAnimatedValue()).scaleValue); mBinding.image.setScaleY(((ValueObject) animation.getAnimatedValue()).scaleValue); &#125; &#125;);&#125; 2.2.3常用方法 void addUpdateListener(ValueAnimator.AnimatorUpdateListener listener)：添加值变化监听器。主要监听值变化，实现动画。 void addUpdateListener(AnimatorUpdateListener listener)：添加动画状态监听器。重写动画开始、结束、取消、重复四个方法，监听不同状态。 void cancel (): 取消动画。 void end ()：让动画到达最后一帧。 void start()：开始动画。 void pause()：暂停动画。 void resume()：继续动画。 void reverse ()：反向播放动画。 boolean isRunning()：是否在运行中。 boolean isStarted()：是否已经开始。 2.2.4属性相关的方法 void setCurrentFraction(float fraction)：设置当前时间因子。即时间到达的百分比。 float getAnimatedFraction()：获取当前时间因子。即时间到达的百分比。 void setCurrentPlayTime (long playTime)：设置当前的时间，取值为0-duration，单位毫秒。 long getCurrentPlayTime ()：获取当前的时间，单位毫秒。 ValueAnimator setDuration (long duration)：设置动画总时长，单位毫秒。 long getDuration ()：获取动画总时长，单位毫秒。 void setFrameDelay (long frameDelay)：设置每一帧之间间隔多少毫秒。 long getFrameDelay ()：获取每一帧之间间隔多少毫秒。 void setInterpolator (TimeInterpolator value)：设置动画的Interpolator，和View Animation的Interpolator通用。 TimeInterpolator getInterpolator ()：获取当前使用的插值器。 void setRepeatCount(int value)：设置重复次数。 int getRepeatCount()：获取重复次数。 void setRepeatMode(int value)：设置重复模式。有RESTART和REVERSE两种。 int getRepeatMode()：获取重复模式。 void setStartDelay(long startDelay)：设置开始前延迟毫秒数。 long getStartDelay()：获取开始前延迟毫秒数。 void getAnimatedValue()：获取计算出来的当前属性值。 getAnimatedValue(String propertyName)：获取计算出来的当前某个属性的值。 void setEvaluator(TypeEvaluator value)：设置求值器。 void setFloatValues(float… values)：设置Float型变化值，一般设置初始值和结束值，当然你也可以设置中间值，因为这是一个可变参数，长度可变。 void setIntValues(int… values)：设置Int型变化值，一般设置初始值和结束值，当然你也可以设置中间值，因为这是一个可变参数，长度可变。 setObjectValues(Object… values)：设置Object型变化值，一般设置初始值和结束值，当然你也可以设置中间值，因为这是一个可变参数，长度可变。 2.2.5监听器ValueAnimator有两个监听器，一个是AnimatorListener，一个AnimatorUpdateListener，通过代码我们查看它们的区别。 AnimatorListener主要是用来监听动画不同状态的监听器，从代码中我们可以看到它有四种不同的状态，当我们需要在不同状态中进行不同操作时，我们可以实现这个监听器。AnimatorUpdateListener是监听ValueAnimaitor的值不断变化的过程，通常使用这个监听器更新控件状态，实现动画过程。 12345678910111213141516171819202122// AnimatorListener主要是用来监听动画不同状态的监听器animator.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; Log.i(&quot;TAG&quot;, &quot;start&quot;); &#125; @Override public void onAnimationEnd(Animator animation) &#123; Log.i(&quot;TAG&quot;, &quot;end&quot;); &#125; @Override public void onAnimationCancel(Animator animation) &#123; Log.i(&quot;TAG&quot;, &quot;cancel&quot;); &#125; @Override public void onAnimationRepeat(Animator animation) &#123; Log.i(&quot;TAG&quot;, &quot;repeat&quot;); &#125;&#125;); 1234567// AnimatorUpdateListener是监听ValueAnimaitor的值不断变化的过程animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; Log.i(&quot;TAG&quot;, &quot;curVal:&quot; + animation.getAnimatedValue()); &#125;&#125;); 三、InterpolatorInterpolator，译名插值器，在我的意思里就是加速器，即这是一个改变我们动画速率的一个工具，可以实现加速、减速、匀速等这些特效。我们在Android基础夯实–重温动画（一）之Tween Animation第五部分讲了Android提供给我们使用的插值器，其实属性动画和视图动画是共用一套Interpolator的。在上面我们讲到，在属性动画中，我们可以通过setInterpolator (TimeInterpolator value)来给我们的动画增加一个插值器，传入参数是TimeInterpolator，通过查阅API，我们可以知道，TimeInterpolator是一个接口。我们再来看看它和我们常用的插值器的关系。 我们常用的插值器，如AccelerateDecelerateInterpolator，AccelerateInterpolator， AnticipateInterpolator，AnticipateOvershootInterpolator等，它们的父类是BaseInterpolator。 而BaseInterpolator是实现了Interpolator，而Interpolator则是继承TimeInterpolator接口。所以究其根源，我们常用的插值器和属性动画使用的TimeInterpolator其实是同一个东西。 既然了解了它们是同一个东西，那么我们就需要了解怎么来实现一个自己的Interpolator了，一般我们只要继承BaseInterpolator，并实现它的getInterpolation(float input)方法就行了。 举个例子，Android提供给我们的LinearInterpolator(这是一个匀速插值器)中，它的getInterpolation是这样的： 123public float getInterpolation(float input) &#123; return input;&#125; 首先我们看一下参数input是什么，input表示当前动画的进度，它的取值范围是0-1，0代表起点，1代表终点，随着动画的播放，input从0到1逐渐变大；而返回值就是指当前的实际进度，听起来有点拗口，我们可以这么想，例如本来当input为0.1的时候，我们返回值如果大于0.1，那么就说明我们从0到0.1这个阶段是一个加速阶段，如果小于0.1，就说明这是一个减速过程。可以看到LinearInterpolator是直接把input返回，可以知道这是一个匀速的过程。 再来看看AccelerateDecelerateInterpolator，这是开始和结束速度慢，中间部分加速。我们来看一下它的getInterpolation函数： 123public float getInterpolation(float input) &#123; return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f;&#125; 可以看到这就是一个余弦公式，因为0-1这个时间内，刚开始和结束前这两个部分斜率是比较低的，所以速度会比较慢，但是中间部分斜率明显变大，所以中间部分呈现加速状态。 经过这两个例子，我们大概知道，当我们需要实现一个Interpolator时，只需要继承BaseInterpolator，并实现它的getInterpolation(float input)方法就行了，举个例子：实现一个0-0.25秒内到达3/4，0.25-0.75秒内从3/4退回1/4，最后0.25秒内从1/4达到终点，先上效果图让大家比较直观了解： 所以我们可以很清楚的列出关系式： 那么在getInterpolation中，对应根据input列出算法： 那么代码也自然出来了： 123456789101112class MyInterpolator extends BaseInterpolator &#123; @Override public float getInterpolation(float input) &#123; if (input &lt;= 0.25) &#123; return 3 * input; &#125; else if (input &lt;= 0.75) &#123; return (1 - input); &#125; else &#123; return 3 * input - 2; &#125; &#125;&#125; 四、EvaluatorEvaluator在属性动画中也是起着重要的一环。先看一张图： 我们可以看到，当Interpolator返回了当前进度滞后，Evaluator就会根据进度来计算出确定的值，以供监听器返回，所以我们就可以知道了，Evaluator其实就是一个根据我们需求而制作的一个计算器。 其实在上面的例子我已经简单地教大家自定义了一个Evaluator，在属性动画中，Android 也为我们提供了很多的Evaluator，例如IntEvaluator，FloatEvaluator等，我们可以先看一下IntEvaluator的底层实现： 1234567public class IntEvaluator implements TypeEvaluator&lt;Integer&gt; &#123; public Integer evaluate(float fraction, Integer startValue, Integer endValue) &#123; int startInt = startValue; return (int)(startInt + fraction * (endValue - startInt)); &#125;&#125; 代码非常的简单，只是重写了一个evaluate方法，在返回值中是一条公式，就是根据开始值和结束值，当前进度，计算结果，并返回，这条公式也是非常简单，这里就不详说了。但是实际开发中，有时候原生的Evaluator不适合我们使用的时候，我们就需要自定义一个Evaluator，正如我上面的例子中用到的，当我们使用了自定义的Object作为初始值和结束值时，我们就需要定义一个自己的Evaluator。下面举一个为了自定义而自定义的Evaluator： 由图可知，自定义的Evaluator就是在FloatEvalutor的基础之上加了200个像素，而我自定义的Evaluator也是修改了以下FloatEvaluator的代码： 1234567class MyEvaluator implements TypeEvaluator&lt;Float&gt; &#123; @Override public Float evaluate(float fraction, Float startValue, Float endValue) &#123; return startValue + fraction * (endValue - startValue) + 200; &#125;&#125; 这是FloatEvaluator的代码： 123456public class FloatEvaluator implements TypeEvaluator&lt;Number&gt; &#123; public Float evaluate(float fraction, Number startValue, Number endValue) &#123; float startFloat = startValue.floatValue(); return startFloat + fraction * (endValue.floatValue() - startFloat); &#125;&#125; 所以到这里大家也可以大概了解了怎么自定义Evaluator，非常的简单，实现TypeEvaluator接口，并传入一个类型，也就是初始值和结束值的类型，然后重写evaluate方法，根据当前进度fraction来计算当前的返回值即可。 五、 总结总体来说，ValueAnimator并不会很难，只要我们掌握了Animator的初始化、初始值、结束值、fraction、Evaluator、监听器的概念，那么我们基本掌握了ValueAnimator的使用，当然，伴随着我们的重复使用、加深理解，当然我们离熟悉掌握ValueAnimator也不远了。当然Animator中除了ValueAnimator以外，还有ObjectAnimator，这也是一个非常重要的概念，下一篇，我给大家带来ObjectAnimator的详解。","categories":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/学习/"}],"tags":[{"name":"动画","slug":"动画","permalink":"http://yoursite.com/tags/动画/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/学习/"}]},{"title":"Android基础夯实--重温动画（三）之初识Property Animation","slug":"Android基础夯实--重温动画（三）之初识Property Animation","date":"2017-04-01T16:00:00.000Z","updated":"2018-01-11T10:03:52.266Z","comments":true,"path":"2017/04/02/Android基础夯实--重温动画（三）之初识Property Animation/","link":"","permalink":"http://yoursite.com/2017/04/02/Android基础夯实--重温动画（三）之初识Property Animation/","excerpt":"","text":"每个人都有一定的理想，这种理想决定着他的努力和判断的方向。就在这个意义上，我从来不把安逸和快乐看作生活目的的本身——这种伦理基础，我叫它猪栏的理想。——爱因斯坦 一、摘要Property Animation（属性动画）是一个非常强大的框架，它允许你让任何对象都实现动画效果。 因为不管一个对象是否出现屏幕中，你都可以随时去改变它的属性，而属性动画正是通过在某个时间点改变对象的属性实现动画效果的。Property Animation是在Android 3.0（API 11）之后推出的，以其具有高扩展性，解决了一些View Animation所不能解决的问题，所以，对于Android开发者来说，Property Animation是一个非常重要的知识点。 本文主要对ValueAnimator做介绍，如果大家有兴趣，可以继续阅读本动画系列其他相关文章，作者也在不断更新完善相关内容，希望大家可以指出有误之处。 1.1 背景由于Tween Animation（补间动画）只能实现简单的四种的动画（alpha、scale、rotate、translate），要想实现比较复杂的动画就难以满足需求，而Frame Animation只是改变了View对象绘制的背景，而没有改变View对象本身。所以当我们想使用View Animation实现一些特殊的动画效果时，就比较困难了。例如，当我们想改变一个控件的背景颜色时，视图动画并不能实现；当我们想设置一个按钮在位置转换之后，仍然保持点击事件，视图动画也不能实现。在这个背景之下，属性动画应运而生。 1.2 区别说了这么多，那么视图动画和属性动画到底有什么区别呢？ 首先，在直观上，属性动画是区别于视图动画的： (1) 时间不一样： 视图动画是从API LEVEL 1就引入了；而属性动画是从API LEVEL 11之后才引入。 (2) 名字不一样： 视图动画的Tween Animation命名为xxxAnimation、Frame Animation命名为AnimationDrawable；而属性动画，则命名为xxxAnimator。 (3) 包名不一样： 视图动画的Tween Animation在包android.view.animation下，而Property Animation在包android.animation中。 其次，从根本上，我们可以总结出视图动画和属性动画的两个主要区别： (1) 视图动画只能改变View的位置或者视觉效果，并不能改变其属性。例如：使用Tween Animation对Button实现位移变换后位置改变，但是点击Button最后停留位置时，并不能响应点击事件。怎么理解呢，举个例子： 由上图可知，我们给TextView设置了点击事件，当我们分别使用Tween Animation和Property Animation移动TextView时，当使用Tween Animation位移TextView后，它的点击事件无效，当使用Property Animation移动TextView后，它的点击事件仍然有效。由此可见，视图动画并不能改变View的属性，而属性动画可以。 (2) 视图动画作用对象只限制为View，而属性动画作用对象不限为View，而是任何对象。例如：属性动画可以改变颜色值而视图动画做不到。同样举个例子： 由上图可以看到，当我们需要对一个对象的颜色值进行改变时，视图动画并不能实现这个效果，上图是通过属性动画来实现的，由此可以推测出，视图动画只能对View起作用，而属性动画作用的不只是View，而是对象。 1.3 建议虽然Property Animation的优点要多于View Animation，但是View Animaiton可以让我们花更少的时间和更少的代码去实现，所以如果View Animation已经足以满足我们的日常需要，那么我们就没必要使用Property Animation了，当然，如果我们都涉及到的话，同时使用View Animation和Property Animation可能是更有效的办法。 如果你想了解更权威的解释，可以查看官方文档：Property Animation。 本文主要对Property Animation做介绍，如果大家有兴趣，可以继续阅读本动画系列其他相关文章： Android基础夯实–重温动画（一）之Tween Animation Android基础夯实–重温动画（二）之Frame Animation 二、工作原理在讲述具体Property Animation相关API之前，我想先给大家讲一下属性动画是如何工作的。下面通过一个例子，这是Android开发指南上面的一个例子，我觉得非常好理解，这里就搬过来了。 首先，我们来看一个例子。如下图描述的是一个对象在它的x方向上进行水平运动的动画（规定右方向为正轴），当然我们可以对应成手机屏幕上的位置。这个动画的时长为40ms，对象在x正方向运动了40个像素，在每个10ms内，这个对象就往x正方向运动10个像素，在第40ms时，这个动画停在了x方向上的40像素，这是一个水平匀速运动的例子。 当然，我们也可以给动画定义一个具有不匀速插值器(Interpolation)，是它运动过程为不匀速。如下图也是一个对象的运动过程，但是它并不是匀速运动，而是开始加速，在结束前减速。这个对象仍然是在40秒内运动了40个像素的距离，但是这个过程是不匀速的，它从开始到中间位置进行了加速运动，在中间位置到结束位置则进行了减速运动。 从上面两个例子可以看到，当我们想要一个对象实现一定的动画效果时，我们可以通过对应的图，还有相关的数据，和相关数据伴随时间的变化来描述该动画过程，但是我们的属性动画的内部是如何像我们这样来描述自身的变化过程的呢？以ValueAnimator为例，我们来看一下属性动画的重要组成部分，如下图所示。 ValueAnimator是属性动画最基础的一个类（我们暂且不深究它，反正它能帮助我们实现图2的先加速后减速的过程）。首先它在内部封装了非常重要的两个接口，第一个就是TimeInterpolator，另一个是TypeEvaluator。大家在心里必须先有个概念，在所有的属性动画里面，都拥有这两个东西。 TimeInterpolator是什么呢？非常简单，就是我们上面所说的插值器，简单来说就是描述对象加速度的一个东西，再简单一点来说就是描述速度变化的一个东西。 TypeEvaluator又是什么呢？大家可以理解为求值器，它是根据上面的插值器来计算对象属性具体值的这么一个东西。 ValueAnimator在执行之前，首先会把时间分为百分数，由0~1，如上图动画过程为40ms，那么在10ms时，时间因子为0.25，在40ms时，时间因子为1。 在计算完时间因子之后，ValueAnimator会调用TimeInterpolator来进行计算插值因子，在图2对应为速度，对应10ms时的速度我们知道会比20ms时的速度会低；而图1中，每一个时刻的速度都一样，所以TimeInterpolator大概是做这么一件事情。 在TimeInterpolator计算完了之后，那么我们的TypeEvaluator就要起作用了，因为上图对应的是对象的位置变化，所以TypeEvaluator为IntEvaluator。这个TypeEvaluator主要是根据TimeInterpolator提供的插值因子(速度)，还有startPropertyValue(开始时间)和endPropertyValue(结束时间)，计算出某个时刻的属性值(位移)，如图2，假如t=10ms时刻，TimeInterpolator给我们返回值为0.15，那么这时在x方向上的位移为0.15 * (40 - 0) = 6。 而这种计算过程在动画执行时间(duration)内是不断重复的，因为ValueAnimator有一个叫做AnimatorUpdateListener的监听器，它会跟踪动画的每一个时刻，所以我们可以在里面进行不断的计算，通过getAnimatedValue()来获取最新值，直到动画结束。 一个属性动画的执行过程大概如上，相信大家已经对属性动画有了基本的了解，那么我们下面根据API来对属性动画进行详细讲解。 三、API概况前面我们说到，属性动画机制所有相关的类都位于android.animation包之下，所以大家有需要可以到官方文档中进行查阅。下面几个表格是属性动画中常用的类，首先给大家大概介绍。 表格1. Animators Class Description ValueAnimator 针对值变化的Animator。 ObjectAnimator 针对Object变化的Animator。 AnimatorSet 运行一组Animator的集合。 Animator类作为属性动画的基类，它是一个抽象类，它提供了实现动画的基本架构，但是我们不能直接使用它，因为它只是提供了最基本的的实现动画的方法，只有让它的子类继承它并进行相应扩展之后，我们才会使用它实现动画。在属性动画中，Animator包括了ValueAnimator、ObjectAnimator和AnimatorSet三个子类，我们分别来介绍一下这三个类。 表格2. Evaluators Class Description TypeEvaluator 求值器接口，所有求值器必须实现该接口。 IntEvaluator 计算Int类型的求值器。 FloatEvaluator 计算Float类型的求值器。 ArgbEvaluator 计算颜色值类型的求值器。 API中为我们提供了求值器的接口TypeEvaluator，当然还要它的实现类，例如IntEvaluator、FloatEvaluator、ArgbEvaluator、 IntArrayEvaluator、FloatArrayEvaluator等，它们都是根据fraction因子来计算出对应的属性值，当然我们也可以自定义自己的Evaluator。 表格3. Interpolators Class Description TimeInterpolator Animator的插值器接口。 TimeInterpolator作为属性动画的插值器接口，我们都知道在View Animation中有很多插值器，例如AccelerateDecelerateInterpolator(前后减速，中间加速)、AccelerateInterpolator（先慢后加速）等插值器，在属性动画中我们同样可以使用这些插值器，这里就不详细列出来了，不了解的同学可以看我之前的文章。当然，我们也可以自定义自己的Interpolator。 四、结语由于文章篇幅过长，不利于大家阅读，所以这篇文章首先给大家介绍属性动画这个概念，相信通过例子和文字的介绍，大家也已经对属性动画有所了解，那么接下来，我就会给大家详细讲解属性动画中的每一个知识点，当然，也会分多篇文章进行分析，如果你已经准备好，请继续阅读。","categories":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/学习/"}],"tags":[{"name":"动画","slug":"动画","permalink":"http://yoursite.com/tags/动画/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/学习/"}]},{"title":"Android基础夯实--重温动画（二）之Frame Animation","slug":"Android基础夯实--重温动画（二）之Frame Animation","date":"2017-03-26T16:00:00.000Z","updated":"2018-01-11T09:58:58.825Z","comments":true,"path":"2017/03/27/Android基础夯实--重温动画（二）之Frame Animation/","link":"","permalink":"http://yoursite.com/2017/03/27/Android基础夯实--重温动画（二）之Frame Animation/","excerpt":"","text":"心灵鸡汤：天下事有难易乎，为之，则难者亦易矣；不为，则易者亦难矣。 摘要当你已经掌握了Tween Animation之后，再来看Frame Animation，你就会顿悟，喔，原来Frame Animation简单多了，那么恭喜你，你已经在Animation这条路上走得越来越远了，当你花十来分钟认真看完这篇文章，你就已经走完了动画这条小路的2/3。 概述我们都知道，在Android系统中，官方给我们提供了两种类型的动画：属性动画(Property Animation) 和 视图动画(View Animation)，而视图动画又包含了两种类型：补间动画(Tween animation) 和 帧动画(Frame animation)。 在上一节我们已经对Tween Animation进行了详细讲解，这一片，我会给大家介绍视图动画的另一种 Frame Animation。 在开发中，除了常用的Tween Animation以外，我们还会用到Frame Animation，就是我们所说的帧动画，之所以要实现帧动画是因为它可以实现类似电影的动态效果，因为我们平时所拍的视频也是通过一张张照片插入每一帧，串联起来，从而实现连续播放的视觉效果，而这Tween Animation是无法实现，只能通过Frame Animation来实现。例如我们常见的App动态引导页，很多都是通过Frame Animation来实现的。 总体来说，Frame Animation实现起来也是比较简单，本文也是主要做一个抛砖引玉，只做基本介绍，更多进阶知识需要大家日后摸索，更权威解释可以看官方文档：Frame Animation。以下先通过Demo给大家更直观地展示Frame Animation。 本文主要对View Animation的Frame Animation做介绍，如果大家有兴趣，可以继续阅读本动画系列其他相关文章，作者也在不断更新完善相关内容，希望大家可以指出有误之处。 Demo这个Demo主要是使用Frame Animation来实现ImageView播放gif图效果。 效果图 代码实现 首先在res/drawable/目录下，增添一个frame.xml文件，里面主要写每一帧播放哪一张照片。最外层标签必须是animation-list，子标签item对应每一帧，每一个item里面的drawable属性对应图片位置、duration对应一帧的时长。 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot;&gt; &lt;item android:drawable=&quot;@drawable/g1&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/g2&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/g3&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/g4&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/g5&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/g6&quot; android:duration=&quot;200&quot; /&gt;&lt;/animation-list&gt; 在Activity中，实现如下代码： //将控件背景设置为我们的AnimationDrawable资源文件 image.setBackgroundResource(R.drawable.frame); mBinding.play.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { //拿到要编译成AnimationDrawable的背景 AnimationDrawable imageAnimation = (AnimationDrawable)image.getBackground(); //开始动画 imageAnimation.start(); } }); Frame Animation在Android的官方文档中，Google对Frame Animation的讲解只是用了比较小的篇幅，可能是因为过于简单，当然，大家通过我上面所说的例子也可以看得出Frame Animation的使用也是非常的简单，下面主要介绍Frame Animation的要点。 文件位置在资源文件夹下：res/drawable/filename.xml 编译在上面的例子我们可以了解到，在Activity中，我们是通过image.getBackground()获取到的对象转为了AnimationDrawable，这是因为在我们的xml文件被编译器编译之后就变成了 AnimationDrawable类。 语法&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=[&quot;true&quot; | &quot;false&quot;] &gt; &lt;item android:drawable=&quot;@[package:]drawable/drawable_resource_name&quot; android:duration=&quot;integer&quot; /&gt; &lt;/animation-list&gt; 标签 &lt; animation-list &gt; ：外层必须要的标签，里面包含一个以上的标签 属性： android:oneshot：true则只运行一次，false则重复动画。 &lt; item &gt; ：每一帧的动画，必须是的子标签。 属性： android:drawable：对应资源文件。 android:duration：每一帧时长。 AnimationDrawableAnimationDrawable就是对应于我们自身定义的xml文件，在Java代码中将xml对象转为了AnimationDrawable之后，我们就可以通过它来获取xml文件里面的属性。 父类AnimationDrawable继承于Object -&gt; Drawable -&gt; DrawableContainer。 接口实现了Runnable, Animatable接口。 XML文件中的变量 android:drawable： 用于该帧的图片。 android:duration： 每一帧的时长。 android:oneshot： true则只运行一次，false则重复动画。 android:variablePadding： 如果true，允许drawable文件的当前状态改变。 android:visible： 是否可见。 方法 void addFrame (Drawable frame, int duration)： 添加一帧动画到动画里面。 int getDuration (int i)： 获取第i帧的时长。 Drawable getFrame (int index)： 获取第i帧的Drawbale。 int getNumberOfFrames ()： 获取共有多少帧。 void inflate (Resources r, XmlPullParser parser, AttributeSet attrs, Resources.Theme theme)： 从XML资源里面加载一个Drawable文件。 boolean isOneShot ()： 判断是否单次播放。 boolean isRunning ()： 判断动画是否还在运行。 Drawable mutate ()： 一个drawable如果使用了mutate()方法，那么对这个drawable属性（包括设置drawable的透明度）修改将不会共享。 void setOneShot (boolean oneShot)： 设置动画播放一次或者循环。 boolean setVisible (boolean visible, boolean restart)： 设置该AnimationDrawable是否可见。 void start ()： 播放。 void stop ()： 停止。 void unscheduleSelf (Runnable what)： 让动画重新回到-1帧。 总结Frame Animation总体来说比较简单，通过XML的划分帧，在Java代码中获取到编译的AnimationDrawable，然后进行播放，难点不多，却是很多引导页的常用实现方法。","categories":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/学习/"}],"tags":[{"name":"动画","slug":"动画","permalink":"http://yoursite.com/tags/动画/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/学习/"}]},{"title":"Android基础夯实--重温动画（一）之Tween Animation","slug":"Android基础夯实--重温动画（一）之Tween Animation","date":"2017-03-20T16:00:00.000Z","updated":"2018-01-11T09:56:08.390Z","comments":true,"path":"2017/03/21/Android基础夯实--重温动画（一）之Tween Animation/","link":"","permalink":"http://yoursite.com/2017/03/21/Android基础夯实--重温动画（一）之Tween Animation/","excerpt":"","text":"心灵鸡汤：真正成功的人生，不在于成就的大小，而在于你是否努力地去实现自我，喊出自己的声音，走出属于自己的道路。 摘要不积跬步，无以至千里；不积小流，无以成江海。学习任何东西我们都离不开扎实的基础知识，这次我们重温Android中让我们又爱又恨的动画。即便没有很好的算法思想，但是掌握了Animation的基础，我们同样可以通过动画给我们的App增色不少。 概述在我们日常开发中，我们都希望我们的App拥有及其炫酷的动画效果，除了一些SDK提供给我们拥有炫酷动画效果的控件外，都需要我们自己来实现。在Android系统中，官方给我们提供了两种类型的动画：属性动画(Property Animation) 和 视图动画(View Animation)，而视图动画又包含了两种类型：补间动画(Tween animation) 和 帧动画(Frame animation)。 Property Animation(属性动画)：通过改变对象的属性来实现动画效果。 View Animation(视图动画)：包括了以下两种动画类型。 Tween Animation(补间动画)：通过对视图进行一系列的动作变化实现动画效果。 Frame Animation(帧动画)：通过一组图片有序播放实现动画视觉效果。 为此，由于篇幅过长，笔主通过三篇博文来重温Animation的相关基础知识，内容主要作为抛砖引玉，围绕这三种动画作简单的介绍，因为所有的动画都是以这几种动画为基础，配合其他的技术，例如自定义View、还有一些曲线函数等，做出很多炫酷的效果。但是，炫酷动画万万千，我们做的每一个动画需求都是源自设计师的灵感，所以这篇文章就不对动画的高阶讲解，相反，是作为抛砖引玉，所以如果你已经非常熟悉动画相关，可以跳过，但是如果你对动画还是不了解，不妨继续看下去。 当然，更权威的解释请查看官方文档：Animation Resources 本文首先对View Animation的Tween Animation做介绍，如果大家有兴趣，可以继续阅读本动画系列其他相关文章，作者也在不断更新完善相关内容，希望大家可以指出有误之处。 Tween Animation，翻译为补间动画，是View Animation两种中的一种，是Android开发中使用最普遍的动画，当然也是使用率最高的一种动画，因为它能够基本满足我们的动画需要，主要是通过对控件实现透明度(alpha)、尺寸(scale)、位置(translate)、旋转rotate)进行改变，通过集合(set)的方式，实现连续的动画效果。 一、动画资源文件的位置 二、类型Tween Animation是View Animation其中之一，Tween Animation可以实现对控件实现以下四种变换: alpha：透明度渐变动画效果 scale：尺寸变化动画效果 translate：位置移动动画效果 rotate：转移旋转动画效果 三、使用方式 在XML文件中定义一系列的动画标签，所有便签在set便签里面构成集合 Java文件中代码实现 之所以可以这样，是因为四个便签都有对应的Java类：AlphaAnimation, RotateAnimation, ScaleAnimation, TranslateAnimation。 所在包：android.view.animation.* 都继承于父类：android.view.animation.Animation 四、Animation类Tween Animation的所有效果都是继承于Animation类，Animation类作为一个抽象类，提供了动画基本属性的实现，需要由具体的子类来具体实现。 直接子类 AnimationSet：代表着一组可以一起播放的动画。 AlphaAnimation：控制一个对象透明度的动画。 RotateAnimation：控制一个对象旋转的动画。 ScaleAnimation：控制一个对象尺寸的动画。 TranslateAnimation：控制一个对象位置的动画。 监听器 Animation.AnimationListener：动画监听器。主要包括监听动画执行中、执行结束、循环执行三个过程。 12345678910111213141516mAnimation.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; // 动画执行时 &#125; @Override public void onAnimationEnd(Animation animation) &#123; // 动画结束时 &#125; @Override public void onAnimationRepeat(Animation animation) &#123; // 动画循环时 &#125; &#125;); 属性及其对应方法(所有子类都拥有) android:detachWallpaper： 是否在壁纸上运行 1Java方法：setDetachWallpaper(boolean detachWallpaper) android:duration： 动画时长，单位毫秒。 1Java方法：setDuration(long) android:fillAfter： 设置为true，控件动画结束时将保持动画最后一帧（xml文件中，需要设置在set便签才生效）。 1Java方法：setFillAfter(boolean) android:fillBefore： 设置为true，控件动画结束时将保持动画开始第一帧（感觉很坑爹，设置true和false还有删除这个属性，效果都一样）。 1Java方法：setFillBefore(boolean) android:fillEnabled： 效果和fillBefore一样（同样坑爹，经测试这个属性可有可无，求打脸。 1Java方法：setFillEnabled(boolean) android:interpolator： 插值器。设置动画速率的变化(譬如加速、减速、匀速等)，后面详说。 1Java方法：setInterpolator(Interpolator) android:repeatCount： 动画重复次数。 1Java方法：setRepeatCount(int) android:repeatMode： 重复模式，有reverse(倒序)和restart(重复)两种，必须配合repeatCount一起使用。 1Java方法：setRepeatMode(int) android:startOffset： 延迟一定毫秒之后才开始动画。 1Java方法：setStartOffset(long) android:zAdjustment： 表示被设置动画的内容在动画运行时在Z轴上的位置，有以下三个值 normal 默认值，保持内容在Z轴上的位置不变 top 保持在Z周最上层 bottom 保持在Z轴最下层1Java方法：setZAdjustment(int) 五、InterpolatorInterpolator，又名插值器，主要是实现动画的速率变化。Interpolator作为一个接口，然后抽象类BaseInterpolator实现Interpolator接口，在BaseInterpolator的子类就是一系列Android提供的插值器。 用法： 在XML的标签下设置:android:interpolator=”@android:anim/accelerate_decelerate_interpolator” 在JAVA代码中使用：animation.setInterpolator(new AccelerateDecelerateInterpolator()); 以下为Andorid所提供的所有插值器： 1、AccelerateDecelerateInterpolator：开始和结束速度慢，中间部分加速。 2、AccelerateInterpolator：开始缓慢，然后加速。 3、AnticipateInterpolator: 开始后退，然后前进。 4、AnticipateOvershootInterpolator: 开始后退，然后前进，直到超出目标值，再后退至目标值。 5、BounceInterpolator：在结束时弹跳。 6、CycleInterpolator：在指定数量的周期内重复动画，速度变化遵循正弦规律。 7、DecelerateInterpolator：开始加速，结束缓慢。 8、LinearInterpolator：匀速。 9、OvershootInterpolator：前进，直到超出目标值，再后退至目标值。 10、PathInterpolator：根据路径变化改变速率。 关于以上所有插值器的Demo： 六、AnimationSetAnimationSet是动画中非常重要的概念，继承于Animation类，它将很多独立的动画包裹到一个集合内，形成一个共同作用的动画效果。例如，我们会在res/anim/目录下的xml文件里面这样实现一个包含多种效果的动画(透明度、尺寸、位置、旋转)： 123456789101112131415161718192021222324252627282930&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fillAfter=&quot;true&quot; android:shareInterpolator=&quot;false&quot;&gt; &lt;scale android:duration=&quot;1500&quot; android:fromXScale=&quot;1.0&quot; android:fromYScale=&quot;1.0&quot; android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toXScale=&quot;1.4&quot; android:toYScale=&quot;0.6&quot; /&gt; &lt;set android:duration=&quot;1000&quot; android:interpolator=&quot;@android:anim/accelerate_interpolator&quot; android:startOffset=&quot;1500&quot;&gt; &lt;scale android:fromXScale=&quot;1.4&quot; android:fromYScale=&quot;0.6&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toXScale=&quot;0.0&quot; android:toYScale=&quot;0.0&quot; /&gt; &lt;rotate android:fromDegrees=&quot;0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toDegrees=&quot;-45&quot; /&gt; &lt;/set&gt;&lt;/set&gt; 效果如下： 当然，你可以使用Java代码来实现，逻辑和在XML中实现的是一样的，如下： 123456789101112131415161718192021222324252627282930313233343536public class MainActivity extends AppCompatActivity &#123; private ActivityMainBinding mainBinding; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main); //参数为false，不共享Interpolator AnimationSet set = new AnimationSet(false); set.setFillAfter(true); // Scale动画 ScaleAnimation scaleAnimation = new ScaleAnimation(1.0f, 1.4f, 1.0f, 0.6f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); scaleAnimation.setInterpolator(new AccelerateDecelerateInterpolator()); scaleAnimation.setDuration(1500); set.addAnimation(scaleAnimation); // mSet集合 AnimationSet mSet = new AnimationSet(true); mSet.setInterpolator(new AccelerateInterpolator()); mSet.setDuration(1000); mSet.setStartOffset(1500); // Scale动画 ScaleAnimation mScaleAnimation = new ScaleAnimation(1.4f, 0.0f, 0.6f, 0.0f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); mSet.addAnimation(mScaleAnimation); // Rotate动画 RotateAnimation mRotateAnimation = new RotateAnimation(0.0f, -45.0f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); mSet.addAnimation(mRotateAnimation); set.addAnimation(mSet); mainBinding.image.startAnimation(set); &#125;&#125; 构造函数 AnimationSet(Context context, AttributeSet attrs) ：当需要加载AttributeSet时使用的构造函数。 AnimationSet(boolean shareInterpolator)：当从代码实现AnimationSet时，传入是否子动画是否共享插值器参数。 主要属性及其方法(父类以外的)Java方法 void addAnimation (Animation a)： 把一个子动画加到Animation Set中去。 long computeDurationHint ()： 获取最长时间的子动画的时间，单位毫秒。 List getAnimations ()： 获取所有子动画对象的集合。 long getStartTime ()：获取动画什么时候应该播放，如果方法返回常量 START_ON_FIRST_FRAME (-1)，表明动画未播放。 **boolean getTransformation (long currentTime, Transformation t)：** 获取帧动画执行到目前时的变换信息，存到Transformation中，主要用作调试用。 例如我们需要当前Scale动画的变换信息： 1234567Transformation tf = new Transformation();if (scaleAnimation!=null)&#123; scaleAnimation.getTransformation(AnimationUtils.currentAnimationTimeMillis(), tf); System.out.println(&quot;Matrix:&quot; + tf.getMatrix()); System.out.println(&quot;Alpha:&quot; + tf.getAlpha()); System.out.println(&quot;TransformationType:&quot; + tf.getTransformationType());&#125; **void initialize (int width, int height, int parentWidth, int parentHeight)：** 初始化动画的宽高和父动画的宽高。 void reset ()： 重置动画的初始状态。 void restrictDuration (long durationMillis)： 限制动画不能超过durationMillis个毫秒。 boolean willChangeBounds ()： 动画是否会改变view的尺寸边界。true为会。 boolean willChangeTransformationMatrix ()： 动画是否会改变view的矩阵。 七、AlphaAnimationAlphaAnimation是继承于Animation的一个动画类型，它通过控制控件的透明度变化来实现动画效果，如我们常见的淡入淡出效果就是通过AlphaAnimaiton实现。 不多说，我们来通过例子看一下AlphaAnimation的实现消失动画效果： 还是有两种写法，一种在XML里定义动画的样式，一种在Java代码里实现动画的样式。 写法一 在res/anim目录下定义alpha.xml文件，在文件内写： 1234&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;2500&quot; android:fromAlpha=&quot;1.0&quot; android:toAlpha=&quot;0.0&quot; /&gt; 在Activity中加载xml文件，并绑定控件播放动画： 12AlphaAnimation animation = (AlphaAnimation) AnimationUtils.loadAnimation(getApplicationContext(), R.anim.alpha);image.startAnimation(animation); 写法二 直接在Java代码中实现： 123AlphaAnimation animation = new AlphaAnimation(1.0f, 0.0f);animation.setDuration(2500);mBinding.image.startAnimation(animation); 构造函数 AlphaAnimation(Context context, AttributeSet attrs)：当需要加载AttributeSet时使用的构造函数。 AlphaAnimation(float fromAlpha, float toAlpha)：构造函数传入fromAlpha(开始时透明度)， toAlpha(结束时透明度) 主要属性及其对应方法(父类以外的)XML属性 android:fromAlpha： 动画开始前控件的透明度，取值0.0-1.0，从透明到不透明。 android:toAlpha： 动画结束时控件的透明度，取值0.0-1.0，从透明到不透明。 Java方法 boolean willChangeBounds ()： 动画是否会改变view的尺寸边界。true为会。 boolean willChangeTransformationMatrix ()： 动画是否会改变view的矩阵。 void applyTransformation (float interpolatedTime, Transformation t)： AlphaAnimation的具体实现，只能在AlphaAnimation的子类中重写来实现自己需要的动画效果。 八、ScaleAnimationScaleAnimation是继承于Animation的一个动画类型，它通过控制控件的尺寸大小来实现动画效果，如我们常见的放大，缩小效果就是通过ScaleAnimation实现。 同样，先示范： 还是有两种写法，一种在XML里定义动画的样式，一种在Java代码里实现动画的样式。 写法一 在res/anim目录下定义scale.xml文件，在文件内写： 123456789101112131415161718192021&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fillAfter=&quot;true&quot;&gt; &lt;scale android:duration=&quot;1500&quot; android:fromXScale=&quot;1.0&quot; android:fromYScale=&quot;1.0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toXScale=&quot;2.0&quot; android:toYScale=&quot;2.0&quot; /&gt; &lt;scale android:duration=&quot;1500&quot; android:fromXScale=&quot;1.0&quot; android:fromYScale=&quot;1.0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:startOffset=&quot;1500&quot; android:toXScale=&quot;0.0&quot; android:toYScale=&quot;0.0&quot; /&gt;&lt;/set&gt; 在Activity中加载xml文件，并绑定控件播放动画： 12Animation animation = AnimationUtils.loadAnimation(getApplicationContext(), R.anim.scale);image.startAnimation(animation); 写法二 在Java代码中实现： 12345678910111213141516AnimationSet set = new AnimationSet(false);set.setFillAfter(true);// 构造函数 fromX, toX, fromY, toY, pivotXType, pivotXValue, pivotYType, pivotYValue// pivotXType和pivotYType都有三种取值：Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, Animation.RELATIVE_TO_PARENTScaleAnimation sa1 = new ScaleAnimation(1.0f, 2.0f, 1.0f, 2.0f, Animation.RELATIVE_TO_SELF,0.5f, Animation.RELATIVE_TO_SELF, 0.5f);sa1.setDuration(1500);ScaleAnimation sa2 = new ScaleAnimation(1.0f, 0.0f, 1.0f, 0.0f, Animation.RELATIVE_TO_SELF,0.5f, Animation.RELATIVE_TO_SELF, 0.5f);sa2.setDuration(1500);sa2.setStartOffset(1500);set.addAnimation(sa1);set.addAnimation(sa2);mBinding.image.startAnimation(set); 构造函数 ScaleAnimation(Context context, AttributeSet attrs)： 当需要加载AttributeSet时使用的构造函数。 ScaleAnimation(float fromX, float toX, float fromY, float toY)： X方向放大（缩小）前的相对比例，X方向放大（缩小）后的相对比例，Y方向放大（缩小）前的相对比例，Y方向放大（缩小）后的相对比例。 ScaleAnimation(float fromX, float toX, float fromY, float toY, float pivotX, float pivotY)： pivotX和pivotY是缩放动画围绕的中心点，当为数值时，表明是屏幕上的绝对坐标值，当为百分数（如50%）时，为相对自己本身控件的比例值，当为百分数加p（如50%p）时，为相对父布局的比例值。 ScaleAnimation(float fromX, float toX, float fromY, float toY, int pivotXType, float pivotXValue, int pivotYType, float pivotYValue)： 当我们需要输入pivotXValue和pivotYValue为百分数或者百分数加p类型的时候，我们用第三个构造函数显示是不行的，这时候需要传入pivotXType和pivotYType，它们有三种取值：Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, Animation.RELATIVE_TO_PARENT。 主要属性及其方法(父类以外的)XML属性 android:fromXScale： 动画开始前的X方向上的尺寸。 android:fromYScale： 动画开始前的Y方向上的尺寸。 android:toXScale： 动画结束时的X方向上的尺寸。 android:toYScale： 动画结束时的Y方向上的尺寸。 android:pivotX： 缩放动画围绕X方向的中心点，当为数值时，表明是屏幕上的绝对坐标值，当为百分数（如50%）时，为相对自己本身控件的比例值，当为百分数加p（如50%p）时，为相对父布局的比例值。 android:pivotY： 缩放动画围绕Y方向的中心点，当为数值时，表明是屏幕上的绝对坐标值，当为百分数（如50%）时，为相对自己本身控件的比例值，当为百分数加p（如50%p）时，为相对父布局的比例值。 Java方法 void initialize (int width, int height, int parentWidth, int parentHeight)： 初始化动画的宽高和父动画的宽高。 九、RotateAnimationRotateAnimation是继承于Animation的一个动画类型，它通过控制控件旋转来实现动画效果，如我们常见的转动效果就是通过RotateAnimation实现。 先看一个小demo： 还是有两种写法，一种在XML里定义动画的样式，一种在Java代码里实现动画的样式。 写法一 在res/anim目录下定义rotate.xml文件，在文件内写： 123456789101112131415161718&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fillAfter=&quot;true&quot;&gt; &lt;rotate android:duration=&quot;1000&quot; android:fromDegrees=&quot;0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toDegrees=&quot;360&quot; /&gt; &lt;rotate android:duration=&quot;1500&quot; android:fromDegrees=&quot;0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:startOffset=&quot;2000&quot; android:toDegrees=&quot;-1800&quot; /&gt;&lt;/set&gt; 在Activity中加载xml文件，并绑定控件播放动画： 12Animation animation = AnimationUtils.loadAnimation(getApplicationContext(), R.anim.rotate);image.startAnimation(animation); 写法二 在Java代码中实现： 1234567891011121314AnimationSet set = new AnimationSet(false);set.setFillAfter(true);RotateAnimation ra1 = new RotateAnimation(0f, 360f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);ra1.setDuration(1000);RotateAnimation ra2 = new RotateAnimation(0f, -1800f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);ra2.setDuration(1500);ra2.setStartOffset(1000);set.addAnimation(ra1);set.addAnimation(ra2);mBinding.image.startAnimation(set); 构造函数 RotateAnimation(Context context, AttributeSet attrs)： 当需要加载AttributeSet时使用的构造函数。 RotateAnimation(float fromDegrees, float toDegrees)：从fromDegress角度转到toDegress角度(正数为顺时针，负数为逆时针)。 RotateAnimation(float fromDegrees, float toDegrees, float pivotX, float pivotY)：加上旋转中心点，X方向中心点pivotX和Y方向中心点，取值仍为上面所介绍的三种。 RotateAnimation(float fromDegrees, float toDegrees, int pivotXType, float pivotXValue, int pivotYType, float pivotYValue)： 加上中心点的取值类型。 主要属性及其方法(父类以外的)XML属性 android:fromDegrees： 动画开始前的角度。 android:toDegrees： 动画结束时的角度。 android:pivotX： 缩放动画围绕X方向的中心点，当为数值时，表明是屏幕上的绝对坐标值，当为百分数（如50%）时，为相对自己本身控件的比例值，当为百分数加p（如50%p）时，为相对父布局的比例值。 android:pivotY： 缩放动画围绕Y方向的中心点，当为数值时，表明是屏幕上的绝对坐标值，当为百分数（如50%）时，为相对自己本身控件的比例值，当为百分数加p（如50%p）时，为相对父布局的比例值。 Java方法 void initialize (int width, int height, int parentWidth, int parentHeight)： 初始化动画的宽高和父动画的宽高。 void applyTransformation (float interpolatedTime, Transformation t)： RotateAnimation的具体实现，只能在RotateAnimation的子类中重写来实现自己需要的动画效果。 十、TranslateAnimationTranslateAnimation是继承于Animation的一个动画类型，它通过控制控件位置变化来实现动画效果，如我们常见的位移效果就是通过TranslateAnimation实现。 TranslationAnimation相关的小Demo，围绕四周转动： 只展示一种写法，Java代码实现方式同上： 在res/anim目录下定义translate.xml文件，在文件内写： 123456789101112131415161718192021222324252627282930313233&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fillAfter=&quot;true&quot;&gt; &lt;translate android:duration=&quot;1000&quot; android:fromXDelta=&quot;0&quot; android:fromYDelta=&quot;0&quot; android:toXDelta=&quot;92%p&quot; android:toYDelta=&quot;0&quot; /&gt; &lt;translate android:duration=&quot;1000&quot; android:fromXDelta=&quot;0&quot; android:fromYDelta=&quot;0&quot; android:startOffset=&quot;1000&quot; android:toXDelta=&quot;0&quot; android:toYDelta=&quot;94%p&quot; /&gt; &lt;translate android:duration=&quot;1000&quot; android:fromXDelta=&quot;0&quot; android:fromYDelta=&quot;0&quot; android:startOffset=&quot;2000&quot; android:toXDelta=&quot;-92%p&quot; android:toYDelta=&quot;0&quot; /&gt; &lt;translate android:duration=&quot;1000&quot; android:fromXDelta=&quot;0&quot; android:fromYDelta=&quot;0&quot; android:startOffset=&quot;3000&quot; android:toXDelta=&quot;0&quot; android:toYDelta=&quot;-94%p&quot; /&gt;&lt;/set&gt; 在Activity中加载xml文件，并绑定控件播放动画： 12Animation animation = AnimationUtils.loadAnimation(getApplicationContext(), R.anim.translate);mBinding.image.startAnimation(animation); 构造函数 TranslateAnimation(Context context, AttributeSet attrs)： 当需要加载AttributeSet时使用的构造函数。 TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta)： fromXDelta（动画开始时的X方向上的位置），toXDelta（动画结束始时的X方向上的位置），fromYDelta（动画开始时的Y方向上的位置），toYDelta（动画结束始时的Y方向上的位置） TranslateAnimation(int fromXType, float fromXValue, int toXType, float toXValue, int fromYType, float fromYValue, int toYType, float toYValue)： 加上类型参数。 主要属性及其方法(父类以外的)Java方法 void initialize (int width, int height, int parentWidth, int parentHeight)： 初始化动画的宽高和父动画的宽高。 void applyTransformation (float interpolatedTime, Transformation t)： TranslateAnimation的具体实现，只能在TranslateAnimation的子类中重写来实现自己需要的动画效果。 总结对于很多比较少接触动画的同学，可能都会比较反感，因为觉得动画篇的东西又多又难学，其实不然，就像我们这篇所介绍的Tween Animation，虽然有很多种动画类型，但是几种都是基于父类Animation类，然后在它的基础上进行了稍微扩展，所以当我们认真静下来去看的时候，我们会发现，其实也不过如此。Animation在实际开发中非常常见，尤其本篇所说的最基本的Tween Animation。在Android已经达到了如此成熟的今天，市场上的应用很大一部分依靠炫酷的动画效果来吸引用户，所以掌握动画会帮助你在日后开发中有很大的帮助，不说其他，早点下班是必须的。","categories":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/学习/"}],"tags":[{"name":"动画","slug":"动画","permalink":"http://yoursite.com/tags/动画/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/学习/"}]}]}
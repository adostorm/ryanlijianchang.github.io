{"meta":{"title":"Ryan's Blog","subtitle":null,"description":null,"author":"Ryan Lee","url":"http://yoursite.com"},"pages":[{"title":"生活","date":"2018-01-11T09:07:32.000Z","updated":"2018-01-11T09:07:32.375Z","comments":true,"path":"生活/index.html","permalink":"http://yoursite.com/生活/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-01-11T09:07:38.000Z","updated":"2018-01-11T09:07:38.462Z","comments":true,"path":"关于/index.html","permalink":"http://yoursite.com/关于/index.html","excerpt":"","text":""},{"title":"学习","date":"2018-01-11T09:17:12.000Z","updated":"2018-01-11T09:17:12.341Z","comments":true,"path":"学习/index.html","permalink":"http://yoursite.com/学习/index.html","excerpt":"","text":""}],"posts":[{"title":"2018，你该搭建自己的博客了！","slug":"2018，你该搭建自己的博客了！","date":"2018-01-10T08:56:29.000Z","updated":"2018-01-11T09:38:50.194Z","comments":true,"path":"2018/01/10/2018，你该搭建自己的博客了！/","link":"","permalink":"http://yoursite.com/2018/01/10/2018，你该搭建自己的博客了！/","excerpt":"","text":"首先欢迎各位来参观我的博客：Ryane’s Blog 摘要：这是一篇有关如何使用Github Pages和Hexo搭建自己独立博客的详尽教程，里面介绍了如何使用和配置Hexo框架，如何将Hexo部署到自己的Github项目中，域名注册，以及域名的绑定，还有我在搭建自己博客过程中所遇到的各种困难。 前言我是一名安卓入门开发者，但，我只是入门！而且我对网站开发以及前端的知识几乎是零基础，所以在自己刚接触这个东西的时候，我像很多人一样，都是上网找教程，但是要知道，那都是程序员的教程。所以对于我这个网站技术小白来说，真是很难受，所以藉此机会写一篇让小白看得懂的教程。如果你是一个小白而且又想做自己的博客，可以，请跟着我的脚步，我会带你真真正正做一个属于你自己的博客。 如果你还不知道你为什么要做一个博客，推荐你看：《我为什么写博客》 入门门槛 必须耐得住折腾。 刻苦的学习精神和耐心。 关于Github 一、Github的优点 GitHub是基于git实现的代码托管。git可能是目前最好用的版本控制系统了，非常受欢迎。 GitHub可以免费使用，并且快速稳定。 Github上面的世界很精彩，用久了你的眼界会开阔很多。 二、什么是Github PagesGithub Pages可以被认为是用户编写的、托管在github上的静态网页。 三、为什么要使用Github Pages 可以绑定你的域名(但暂时貌似只能绑定一个)。 简单快捷，使用Github Pages可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。 安装Node.js在 Windows 环境下安装 Node.js 非常简单，仅须到官网下载安装文件并执行即可完成安装。像我的是Windows 64位，直接下载安装，无脑下一步就行了，不需要配置环境变量。 安装Git去Git官网根据你的电脑参数，下载对应版本。 下载完成，通过在命令行输入 git version 查看是否安装成功，有输出版本号说明安装成功。 鼠标邮件菜单里就多了Git GUI Here和Git Bash Here两个按钮，一个是图形界面的Git操作，一个是命令行，我们选择Git Bash Here。 安装教程：如何在windows下安装GIT Git入门教程：Pro Git（中文版） Git基本操作： HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 一、Hexo安装桌面右键鼠标，点击Git Bash Here，输入npm命令即可安装 npm install hexo-cli -g npm install hexo-deployer-git --save 第一句是安装hexo，第二句是安装hexo部署到git page的deployer，两个都需要安装。 如下图即安装完成。 二、Hexo初始化配置创建Hexo文件夹安装完成后，根据自己喜好建立目录（如F:\\Blog\\Hexo），直接进入F:\\Blog\\Hexo文件夹下右键鼠标，点击Git Bash Here，进入Git命令框，执行以下操作。 $ hexo init 安装 Hexo 完成后，Hexo 将会在指定文件夹中新建所需要的文件。Hexo文件夹下的目录如下： 本地查看效果执行下面语句，执行完即可登录localhost:4000查看效果 hexo generate hexo server 登录localhost:4000，即可看到本地的效果如下： 将博客部署到Github Pages上那么现在本地的博客已经搭建起来了，但是我们只可以通过本地连接查看我们的博客。那么我们现在需要做的就是把本地的博客发布到服务器上，让别人也可以连接我们的博客，而Github Pages就帮我完成了这件事情。但是Github Pages的代码就是寄存在Github上面的。那么接下来我们需要在Github上面创建一个新的项目。 一、注册Github账户 访问Github首页 点击右上角的 Sign Up，注册自己的账户 二、创建项目代码库 注册完登陆后，我们就创建一个我们自己的Github Pages项目。点击New repository。 创建要点如下： 三、配置SSH密钥配置Github的SSH密钥可以让本地git项目与远程的github建立联系，让我们在本地写了代码之后直接通过git操作就可以实现本地代码库与Github代码库同步。操作如下： 第一步、看看是否存在SSH密钥(keys)首先，我们需要看看是否看看本机是否存在SSH keys,打开Git Bash,并运行: $ cd ~/. ssh 检查你本机用户home目录下是否存在.ssh目录 如果，不存在此目录，则进行第二步操作，否则，你本机已经存在ssh公钥和私钥，可以略过第二步，直接进入第三步操作。 第二步、创建一对新的SSH密钥(keys)$ssh-keygen -t rsa -C &quot;your_email@example.com&quot; #这将按照你提供的邮箱地址，创建一对密钥 Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter] 直接回车，则将密钥按默认文件进行存储。此时也可以输入特定的文件名，比如/c/Users/you/.ssh/github_rsa 接着，根据提示，你需要输入密码和确认密码（说到这里，如果你很放心，其实可以不用密码，就是到输密码的地方，都直接回车，所以每次push就只管回车就行了。所谓的最安全的密码，就是没有密码 哈哈）。相关提示如下： Enter passphrase (empty for no passphrase): [Type a passphrase] Enter same passphrase again: [Type passphrase again] 输入完成之后，屏幕会显示如下信息： Your identification has been saved in /c/Users/you/.ssh/id_rsa. Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub. The key fingerprint is: 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 第三步、在GitHub账户中添加你的公钥运行如下命令，将公钥的内容复制到系统粘贴板(clipboard)中。 clip &lt; ~/.ssh/id_rsa.pub 接着： 登陆GitHub,进入你的Account Settings. 2.选择SSH Keys 3.粘贴密钥，添加即可 第四步、测试可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改： $ ssh -T git@github.com 如果是下面的反馈： The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established. RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. Are you sure you want to continue connecting (yes/no)? 不要紧张，输入yes就好，然后会看到： 第五步、设置用户信息现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字根据自己的喜好自己取，而不是GitHub的昵称。 $ git config --global user.name &quot;ryanlijianchang&quot;//用户名 $ git config --global user.email &quot;liji.anchang@163.com&quot;//填写自己的邮箱 第六步、SSH Key配置成功本机已成功连接到github。 四、将本地的Hexo文件更新到Github的库中第一步、登录Github打开自己的项目 username.github.io 第二步、打开之后，点击SSH，选择SSH类型地址 第三步、复制地址 第四步、打开你一开始创建的Hexo文件夹（如F:\\Blog\\Hexo），用记事本打开刚文件夹下的_config.yml文件 第五步、在配置文件里作如下修改，保存 第六步、在Hexo文件夹下执行：hexo g hexo d 或者直接执行 hexo g -d 执行完之后会让你输入github的账号和密码，输入完后就可以登录我们自己的部署在Github Pages服务器上的博客了。对应的地址是 username.github.io(我的是：ryanlijianchang.github.io)。 假如这时候，报错 ERROR Deployer not found: git，那么就是你的deployer没有安装成功，你需要执行如下命令再安装一次： npm install hexo-deployer-git --save 这样，你再执行hexo g -d，你的博客就部署到Github上了。 第七步、在浏览器上输入自己的主页地址在浏览器上输入Github Pager为我们生成的外链（例如我的是：https://ryanlijianchang.github.io/，而你的只需要把你的github用户名替换掉这个链接中的ryanlijianchang，因为我的用户名是这个，那么你自己的专属博客地址就是：https://[您的用户名].github.io/）即可看到自己的博客了。 当然，每一个人都可以通过这个地址访问到你的博客了。 美化自己博客那么现在我们的博客已经挂在了Github服务器上面，别人已经可以通过地址来登陆我们的博客了，但是我们这时就有了新的需求，就是自己的博客并不好看，那怎么办的？这很简单，要知道很多前端开发者在Hexo框架下开发了很多的主题给我们使用，我们只需要把他们的主题克隆过来，然后通过修改配置文件即可达到我们所需要的效果。 那么我们应该怎么修改呢？ 一、进入Hexo的官网主题专栏 二、挑选我们喜欢的主题可以看到有很多主题给我们选，我们只要选择喜欢的主题点击进去，然后进入到它的github地址，我们只要把这个地址复制下来(例如我是选择：hexo-theme-next这个主题) 三、克隆主题再打开Hexo文件夹下的themes目录（F:\\Blog\\hexo\\themes），右键Git Bash，在命令行输入: git clone https://github.com/iissnan/hexo-theme-next(此处地址替换成你需要使用的主题的地址) 下载中，等待下载完成： 四、修改Hexo配置文件下载完成后，打开Hexo文件夹下的配置文件_config.yml 修改参数为：theme: hexo-theme-next 五、部署主题，本地查看效果返回Hexo目录，右键Git Bash，输入 hexo g hexo s 打开浏览器，输入 http://localhost:4000/ 即可看见我们的主题已经更换了。 六、如果效果满意，将它部署到Github上打开Hexo文件夹，右键Git Bash，输入 hexo clean (必须要，不然有时因为缓存问题，服务器更新不了主题) hexo g -d 七、打开自己的主页，即可看到修改后的效果更多修改效果请查看对应主题的说明文档，点击此查看本主题(Next)对应的说明文档。 在博客写文章一、用hexo发表新文章$ hexo n &quot;文章标题&quot; 其中 我的家 为文章标题，执行命令 hexo n &quot;我的家&quot; 后，会在项目 \\Hexo\\source_posts 中生成 我的家.md文件，用编辑器打开编写即可。 当然，也可以直接在\\Hexo\\source_posts中新建一个md文件，我就是这么做的。写完后，推送到服务器上，执行以下命令即可在我们的站点看到新的文章。 $ hexo g #生成 $ hexo d #部署 # 可与hexo g合并为 hexo d -g 二、用Markdown写文章我们注意到在 \\Hexo\\source_posts 文件夹下存放着我们的文章，它们的格式都是以.md格式结尾的，没错，Hexo也是支持Markdown语法的，所以当我们需要写具有格式化的文章时，我们可以使用支持Markdown语法的编辑器进行文章编译，然后保存文件到 \\Hexo\\source_posts 文件夹下即可。 复制进去之后，只要执行 $ hexo d -g 推送到我们的Github仓库即可。 那么什么是Markdown？Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。 Markdown有什么优点？ 专注你的文字内容而不是排版样式。 轻松的导出 HTML、PDF 和本身的 .md 文件。 纯文本内容，兼容所有的文本编辑器与字处理软件。 可读，直观。适合所有人的写作语言。 我该用什么工具？ Windows下可以使用 MarkdownPad2。 在 Mac OS X 上，我建议你用 Mou 这款免费且十分好用的 Markdown 编辑器。 Web 端上，我强烈推荐 简书 这款产品。 关于Markdown的更多资料可以查看如下： 认识与入门 Markdown Markdown入门指南 将自己的域名关联到Github Pages上很多朋友创建了自己的博客之后会选择买一个属于自己的域名，然后将自己域名绑定到自己的Github Pages博客上，其实这也并不难，只要你有个域名。 一、购买域名如果你不是很有钱，在阿里云上，你只要几块钱就可以买到一个域名。 选择你喜欢的域名，然后购买即可。 二、配置CNAME文件在 \\hexo\\source 文件夹下创建文件 CNAME （新建记事本文件命名CNAME，然后打开） 内容为你的域名，例如我的域名是：ryane.top 在Hexo文件夹提交 hexo g -d 三、修改DNS的DNS1.如果你是在阿里云购买域名的话，请登录阿里云网站。打开个人中心，点击域名 2.选择管理 3.修改DNS为 f1g1ns2.dnspod.net f1g1ns1.dnspod.net 四、域名解析 打开DNSPOD，注册一个账户 点击添加域名，把你的域名添加进去，如无意外，添加完之后就是以下这个状态 此时点击添加记录，添加两个记录，一个主机记录为@， 一个为www，而记录值都是填同一个，填你的博客主页对应的ip，添加完后如下。 但是如何获取ip值呢？打开运行，输入cmd，打开命令窗口输入 ping 主页地址 ， 红色部分即为你的ip值 将IP输入过去，然后会提示你到域名注册的地方修改DNS。等待生效，最迟72小时生效。即可通过你的域名浏览你的博客主页。 结语当你完成了你的博客之后，相信你的心情跟我刚做完的心情是一样的，即便很累，但是当自己的博客成型之后，自己还是有一个成就感的，那么完成后，以后的路还很长，真正想要自己博客能够积累人气，还得靠好的内容，所以认真写文章吧，相信你会受益于此的。 如果大家有什么问题的话，可以在我留言板下留言，我看到评论时会第一时间回答大家。 参考资料： Markdown入门手册中文版 Markdown–入门指南 如何搭建一个独立博客——简明 Github Pages与 jekyll 教程 by cnfeat Hexo搭建Github静态博客 by 金石开 使用SSH密钥连接Github【图文教程】 by 轩枫","categories":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/学习/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/学习/"}]},{"title":"生活在孤独中前行","slug":"生活在孤独中前行","date":"2018-01-05T08:56:29.000Z","updated":"2018-01-11T09:38:45.970Z","comments":true,"path":"2018/01/05/生活在孤独中前行/","link":"","permalink":"http://yoursite.com/2018/01/05/生活在孤独中前行/","excerpt":"","text":"生活不可能像你想象得那么好，但也不会像你想象得那么糟。我觉得人的脆弱和坚强都超乎自己的想象。有时，我可能脆弱得一句话就泪流满面，有时，也发现自己咬着牙走了很长的路。——莫泊桑 以这一句话开始，是因为看了高木直子的《一个人住第五年》。都说人是慢慢成长的，其实不是，人是瞬间长大的，就像是突然间沉淀一般，突然不会谈恋爱了或者说不想谈恋爱了，一个人生活单一却也不会觉得无聊，即便很多时候还是会迷茫却也不会觉得烦躁了。去年的今天我在不一样的城市，背着不一样的书包，留着不一样的发型，走着不一样的路，想着不一样的事情，有着不一样的心思，谁说改变要十年呢。或者说，这一秒的想法和上一秒的想法就不一样，这个世界是瞬间变化的，运转速度是那么快，没有人在意你是不是一个人。而我呢，就是一个人，默默地在做自己的事，感受着生活中的变化，也感受着自己的变化，在不断的变化中，寻找最佳的结合点和平衡点。信奉一句话：变化中求生存。专注和节奏是生活的主旋律。 身边的牛人倒是不少，像是神抵一样的存在，我也只是羡慕想着反正自己也不会变成那样的人，直到有一天跟国内比较有影响力28岁的年轻总裁聊天，才知道原来他也有看不进去书，经常想方案想到撞墙的时候，我们都忘了他们是用怎么样的一个代价才换取来了这样的一个人生。他说，如果你想要去实现梦想，孤独是你的必修课。如果不能沉下心来，就没有办法去实现它，因为那绝对不是一件容易的事情，孤独能让你更坚强，你必须找到自己的生活节奏。 最近迷上一个人到处走，算不上旅行只是周围到处走一走，倒也不会花上太多时间准备，起身就走了。我不会带上相机只是有兴致了拿出手机拍一拍，音乐倒是我走到哪里都不能丢的东西，每个月都会去听几场音乐会，只有音乐，能让看似漫长的等待变成曼妙的旅程，似乎自己跟整个世界都没有关系，只想当一片没有名字的云，徜徉在不知道名字的风景里。我们都会找到自己的生活节奏，然后沉溺其中无法自拔。 曾经学生时代很少去图书馆，觉得那种“每个星期读一本书”对于我来讲有点勉强。但之后的某一天我陪朋友去图书馆，他是一个借书就不会停的人，我也就跟着借了几本。回到家里看微博人人又觉得心里空当当的，索性就拿起书来看，也是在那一天我才发现，其实每个星期看一本书没那么难，那天我一下子把书看完，才觉得这样子的生活是充实的。所以我喜欢读书，读很多书，尽管现在时间很紧，有时候忙得让自己无法开胶，但每天还是会抽出一点时间来，看看书。 要么读书，要么旅行，身体和灵魂，必须有一个在路上。 我告诉自己现实容不得你拖延，拖延只会让我变得更焦虑而已，所以刚开始的时候我规定自己每天提早上床半小时，看上几十页书，很快就变成习惯了。有的时候我不得不感叹如果真的去做一件事情的话，那么这件事情没有那么难。当你真的想要做一件事情的时候，整个世界都会来协助你，就是这种感觉。想起了09年艺考备战时，想起了面试节目时，经常告诉自己的一句话：当你只有一个目标时，全世界都会为你让路。 一个喜欢冒险和旅游的朋友说，只要出发，就能到达，你不出发，就哪里也去不了。如果你不能沉下心来，就什么也做不到。出发永远是最有意义的事，去做就是了。一本书买了不看只是几张纸，公开课下了不看也只是一堆数据，不去看就没有任何意义，反而徒增焦虑，行动力才是最关键的。 你也许也是这样，当你渴望找个人交谈的时候，你们却没有谈什么，于是发现有些事情是不能告诉别人的，有些事情是不必告诉别人的，有些事情是根本没有办法告诉别人的，而有些事情即使告诉了别人，你也会马上后悔，那么最好的办法就是静下来，真正能平静自己的只有自己。 没有人能免得了孤独，与其逃避它不如面对它。孤独并不是一件那么糟糕的事情，与嘈杂相比，一个人生活倒显得自得地多，倒也可以变成一种享受。或许至少需要那么一段时间，几年或几个月，一个人生活，不然怎么能找到自己的节奏知道自己想要什么。这是属于你自己的东西，是你的一部分，你听音乐时，坐地铁时，一个人走在马路上时，它就会流淌出来，让我觉得这个世界似乎在以另外一种形式存在着，我能够清晰地听到自己，不断地在和自己对话交流。所以，我很喜欢独处，喜欢一个人漫无目的的随便走走。 我们都生活在一个不那么如意的世界，当乌云密布我们就摇曳，但阳光总有一天会到来，等阳光照到你的时候，记得开出自己的花就行了，那个你与生俱来的梦想。有的时候梦想很远，有的时候梦想很近，但它总会实现的。我想一个人最好的样子就是平静一点，哪怕一个人生活，穿越一个又一个城市，走过一个又一条街道，仰望一片又一片天空，见证一次又一次别离。 即便世界与我为敌，只要心还透明，就能折射希望。 接下来说说“选择”，选择，是一门艺术，一种技巧，一种生活的情调。什么都有正反两面，有些是我们能把握控制的，有些是我们不能左右的，但是我们有选择的权利，可以选择我们自己的生活。小处说，可以选择一种心情，一件衣服，甚至中午我们要吃什么饭，大处讲，我们可以选择一段感情，一种方式，一种习惯，一种性格，一种态度，一种人生。而这一切的出发点都是我们的内心，依据内心和环境而做出的选择。选择的任何一种形式都要为我们的结果服务的，不然选择就毫无意义，通常我们会采用两种方式思考问题和做出选择：基于自己的真实想法和基于事情的后果。但是都要归到一个点上，你要为你的选择买单。 如果你感觉你会后悔，那么你就不要去选择；如果你选择了，你就永远不要后悔。 然后就是“比较”比较，是一门哲学。比较就像一面镜子，可以知得失，知利弊，知不足，知缺点也知优点。比较是自己的一部历史，给你经验，给你教训，让你更加了解你自己，进而完善自己。在和周围的比较时，别忘了和昨天的你做比较，这样会进步更快。 “变化”，上边已经提到一点，变化其实才是生活的实质，人是在变化的，生活是在变化的，社会是在变化的，整个世界也在不断的变化，而你要不要变化？？？要不要去适应这个世界，赶上节奏？？？当你一种不好的习惯或者性格，把你的而生活搞得很糟糕时，你还在怂恿它，不想改变，为什么？？你已经很清洗地认识到它的弊端了，为什么不变？？当它直到有一天，事情搞到无法挽救的地步，你才想起要改变，是不是有点晚了。人的惰性和致命弱点。这或许我们每个人都经历过，才会一步一步长大成熟。穷则思变，穷则生变，有变才有进步。变，是一种考验和磨练，让你坚强，让你自信，让你成熟。 一个人的思想和认识的变化对他来说，很重要。只有思想上的变革才会有行为上的变化。其实也就是我们所说的想与做的问题，但是一般人所说的想，只是随便的想一想，并没有深入到根本本质的东西，没有认真的分析，要做成一件事，需要什么样的思想、认识，需要什么环境、条件，还有需要自身什么精神或者品质、习惯（如坚持、吃苦、坚强、勤奋、激情等等）这可以说也是一个逻辑思维的过程，但却是做成一件事必不可缺少的过程。想起来电视上狄仁杰说过的一句话：想做成一件事要有三断——判断、推断、果断。也如现在人们所说的三力——判断力、分析力、执行力，所以什么事都不是那么简简单单容易的就做成的，需要你做的很多。 对于“简单”来说，不同的人有不同的认识，一千个读者一千个哈姆雷特。真正的大家、智者、老者所认为的简单，其实是不简单。简单是从复杂中提炼出来的，没有经过复杂哪里来的简单。与其说简单是一种幸福，不如说经历复杂是一种幸福。路遥《平凡世界》上有一句关于幸福的解释，值得借鉴：幸福不只是吃饱穿暖，而是勇敢地去战胜困难，一点一点地不断超越自己！ “平衡”我对平衡感要求很高的，这种思想是我从生态学上学到的，我认为生态学中有一种思想就是平衡和和谐。任何一个环境，包括我们人类所生活的社会环境，都需要在一个平衡和谐的状态下才能持久下去，不然都会被淘汰的，针对一个人个体上说也是一样的，你如果不能保持你内心的一种平衡，你肯定会抱怨的，每个人都一样，都会这样的。那我们该怎样做，才能是我们的身与心、内与外的平衡和谐呢。这是我们要找的东西，因人而异，要量体裁衣。 那么孤独是人生的一部分，缺少了孤独，似乎人生也就不完美了，所以我们应该习惯孤独，爱上孤独，它能告诉你很多人生的秘密。相信我。","categories":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/生活/"}],"tags":[{"name":"鸡汤","slug":"鸡汤","permalink":"http://yoursite.com/tags/鸡汤/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/生活/"}]},{"title":"用RecyclerView做一个小清新的Gallery效果","slug":"用RecyclerView做一个小清新的Gallery效果","date":"2017-12-14T16:00:00.000Z","updated":"2018-01-11T09:41:10.594Z","comments":true,"path":"2017/12/15/用RecyclerView做一个小清新的Gallery效果/","link":"","permalink":"http://yoursite.com/2017/12/15/用RecyclerView做一个小清新的Gallery效果/","excerpt":"","text":"一、简介RecyclerView现在已经是越来越强大，且不说已经被大家用到滚瓜烂熟的代替ListView的基础功能，现在RecyclerView还可以取代ViewPager实现Banner效果，当然，以下做的小清新的Gallery效果也是类似于一些轮播图的效果，如下图所示，这其中使用到了24.2.0版本后RecyclerView增加的SnapHelper这个辅助类，在实现以下效果起来也是非常简单。所以这也是为什么RecyclerView强大之处，因为Google一直在对RecyclerView不断地进行更新补充，从而它内部的API也是越来越丰富。 那么我们从水平滑动为例，我们细分为以下几个小问题： 每一次滑动都让图片保持在正中间。 第一张图片的左边距和最后一张的右边距需要保持和其他照片的左右边距一样。 滑动时，中间图片滑动到左边时从大变小，右边图片滑动到中间时从小变大。 背景实现高斯模糊。 滑动结束时背景有一个渐变效果，从上一张图片淡入淡出到当前图片。 二、实现思路解决以上问题当然也不难，我们分步来讲解下实现思路： (1) 每一次滑动都让图片保持在正中间保持让图片保持在正中间，正如简介中所说，在ToolsVersion24.2.0之后，Google给我们提供了一个SnapHelper的辅助类，它只需要几行代码就能帮助我们实现滑动结束时保持在居中位置： LinearSnapHelper mLinearySnapHelper = new LinearSnapHelper(); mLinearySnapHelper.attachToRecyclerView(mGalleryRecyclerView); LinearSnapHelper类继承于SnapHelper，当然SnapHelper还有一个子类，叫做PagerSnapHelper。它们之间的区别是，LinearSnapHelper可以使RecyclerView一次滑动越过多个Item，而PagerSnapHelper像ViewPager一样限制你一次只能滑动一个Item。 (2) 第一张图片的左边距和最后一张的右边距需要保持和其他照片的左右边距一样由于第0个位置，和最后一个位置的图片比较特殊，其他图片都默认设置他们的页边距和左右图片的可视距离，由于第0页左边没有图片，所以左边只有1倍页边距，这样滑动到最左边时看起来就会比较奇怪，如下图所示。 让第0位置的图片左边保持和其他图片一样的距离，那么就需要动态设置第0位置图片的左边距为2倍页边距 + 可视距离。同理，最后一张也是做同样的操作。 动态修改图片的LayoutParams，由于RecyclerView对Holder的复用机制，我们最好不要在Adapter里面动态修改，这样子首先不够优雅，这里感谢@W_BinaryTree的建议，我们给RecyclerView添加一个自定义的Decoration会让我们的代码更加优雅，只需要重写RecyclerView.ItemDecoration里面的getItemOffsets(Rect outRect, final View view, final RecyclerView parent, RecyclerView.State state)方法，并在里面设置每一页的参数即可，修改如下： public class GalleryItemDecoration extends RecyclerView.ItemDecoration { int mPageMargin = 0; // 每一个页面默认页边距 int mLeftPageVisibleWidth = 50; // 中间页面左右两边的页面可见部分宽度 public static int mItemComusemX = 0; // 一页理论消耗距离 @Override public void getItemOffsets(Rect outRect, final View view, final RecyclerView parent, RecyclerView.State state) { super.getItemOffsets(outRect, view, parent, state); // ... // 动态修改页面的宽度 int itemNewWidth = parent.getWidth() - dpToPx(4 * mPageMargin + 2 * mLeftPageVisibleWidth); // 一页理论消耗距离 mItemComusemX = itemNewWidth + OsUtil.dpToPx(2 * mPageMargin); // 第0页和最后一页没有左页面和右页面，让他们保持左边距和右边距和其他项一样 int leftMargin = position == 0 ? dpToPx(mLeftPageVisibleWidth + 2 * mPageMargin) : dpToPx(mPageMargin); int rightMargin = position == itemCount - 1 ? dpToPx(mLeftPageVisibleWidth + 2 * mPageMargin) : dpToPx(mPageMargin); // 设置参数 RecyclerView.LayoutParams lp = (RecyclerView.LayoutParams) itemView.getLayoutParams(); lp.setMargins(leftMargin, 0, rightMargin, 0); lp.width = itemWidth; itemView.setLayoutParams(lp); // ... } public int dpToPx(int dp) { return (int) (dp * Resources.getSystem().getDisplayMetrics().density + 0.5f); } } 然后，把GalleryItemDecoration传入即可： mGalleryRecyclerView.addItemDecoration(new GalleryItemDecoration()); (3) 滑动时，中间图片滑动到左边时从大变小，右边图片滑动到中间时从小变大这个问题涉及到比较多的问题。 (a) 获取滑动过程中当前位置。 首先，RecyclerView当前的API，并不能让我们在滑动的过程中，简单地获取到我们图中效果中间图片的位置，或许你会说，可以通过mGalleryRecyclerView.getLinearLayoutManager().findFirstVisibleItemPosition()能拿到RecyclerView中第一个可见的位置，但是通过效果可以知道，我们每一个张照片（除去第一张和最后一张）左右两边都是有前一张照片和最后一张照片的部分内容的，所以需要做区分判断是否是中间的照片还是第一张亦或最后一张，然后返回mGalleryRecyclerView.getLinearLayoutManager().findFirstVisibleItemPosition() + 1或者其他。 那么这样又会引出一个问题，当我们把前后照片展示的宽度设置成可配置，即前后照片的露出部分宽度是可配置，那么当我们把屏幕不显示前后照片遗留部分在屏幕的话，那么我们这一个方法又不能兼容了，所以通过这一个方法来获取，或许不那么靠谱。 我们可以这样来计算出比较准确的位置。在RecyclerView中，我们可以监听它的滑动事件： // 滑动监听 mGalleryRecyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() { @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) { super.onScrollStateChanged(recyclerView, newState); } @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { super.onScrolled(recyclerView, dx, dy); // 通过dx或者dy来计算位置。 } }); 里面有一个onScrolled(int dx, int dy)方法，这里面的dx，dy非常有用。首先，通过判断dx，dy是否大于0可以判断它是上、下、左、右滑动，dx &gt; 0右滑，反之左滑，dy &gt; 0 下滑，反之上滑（当然，我这里的滑动是相对于RecyclerView，即列表的滑动方向，手指的滑动方向和这里相反）。其次，dx和dy还能监听每一次滑动在x，y轴上消耗的距离。 举个例子，当我们迅速至列表右边时，onScrolled(int dx, int dy)会不断被调用，通过在方法里面Log输出，你会看到不断输出dx的值，而且他们的大小都是无规律的，而这里的dx就是每一次onScroll方法调用一次，RecyclerView在x轴上的消耗距离。 所以我们可以通过一个全局变量mConsumeX来累加所有dx，当这样我们就可以知道当前RecyclerView滑动的总距离。而我们Demo中每移动到下一张照片的距离(即如下图中所示的移动一页理论消耗距离)是一定的，那么就可以通过当前位置 = mConsumeX / 移动一张照片所需要的距离来获取滑动结束时的位置了。 /** * 获取位置 * * @param mConsumeX 实际消耗距离 * @param shouldConsumeX 移动一页理论消耗距离 * @return */ private int getPosition(int mConsumeX, int shouldConsumeX) { float offset = (float) mConsumeX / (float) shouldConsumeX; int position = Math.round(offset); // 四舍五入获取位置 return position; } (b) 根据位置获取当前页的滑动偏移率 当我们可以准确拿到当前位置时，我们就需要明确一下几个概念。 总的偏移距离：意思是从第一个位置移动到现在当前位置偏移的总距离，即dx的累加结果（也就是上述的mConsumX）。 当前页偏移距离：意思是从上一个位置移动到当前位置偏移距离。 总的偏移率：意思是 总的偏移距离 / 移动一页理论消耗距离。 当前页的偏移率：意思是 当前页偏移距离 / 移动一页理论消耗距离。 我们都知道，获取当前位置方法里面有一个 float offset = (float) mConsumeX / (float) shouldConsumeX; 它的意思就是总的偏移率，例如图中我们当前位置是3，我们从3移动到4时，onScroll方法会不断被调用，那么这个offset就会不断变化，从3.0逐渐增加一直到4.0，图中此时的offset大概是3.2左右，我们知道这一个有什么用呢？试想一下，offset是一个浮点型数，将它向下取整，那就是变成3了，那么3.2 - 3 = 0.2就是我们当前页的偏移率了。而我们通过偏移率就可以动态设置图片的大小，就形成了我们这个问题中所说的图片大小变化效果。所以这里的关键就是获取到当前页的偏移率。 @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { super.onScrolled(recyclerView, dx, dy); // ... // 移动一页理论消耗距离 int shouldConsumeX = GalleryItemDecoration.mItemComusemX; // 获取当前的位置 int position = getPosition(mConsumeX, shouldConsumeX); // 位置浮点值（即总消耗距离 / 每一页理论消耗距离 = 一个浮点型的位置值） float offset = (float) mConsumeX / (float) shouldConsumeX; // 避免offset值取整时进一，从而影响了percent值 if (offset &gt;= mGalleryRecyclerView.getLinearLayoutManager().findFirstVisibleItemPosition() + 1 &amp;&amp; slideDirct == SLIDE_RIGHT) { return; } // 当前页的偏移率 float percent = offset - ((int) offset); // 设置动画变化 setAnimation(recyclerView, position, percent); // ... } (c) 根据偏移率实现动画 现在我们拿到了偏移率，就可以动态修改它们的尺寸大小了，首先，我们需要拿到当前View，前一个View和后一个View，并同时对它们做Scale伸缩。即上面的setAnimation(recyclerView, position, percent)方法里面进行动画操作。 View mCurView = recyclerView.getLayoutManager().findViewByPosition(position); // 中间页 View mRightView = recyclerView.getLayoutManager().findViewByPosition(position + 1); // 左边页 View mLeftView = recyclerView.getLayoutManager().findViewByPosition(position - 1); // 右边页 认真观察图中变化，两种变化： 位置的变化：第一张图片是从mCurView慢慢变成mLeftView，而第二张图片是从mRightView慢慢变成mCurView。 大小变化：第一张图是从大变小，第二张图是从小变大。 理解了以上的变化之后，我们就可以做动画了。 首先说明一点，大家观察我的getPosition(mConsumeX, shouldConsumeX)方法，里面的实现是，当一页滑动的偏移率超过了0.5之后，position就会自动切换到下一页。当然你的实现逻辑不一样，那么后面你的设置动画的方法就不一样。为什么需要明确这一点呢？因为当我滑动超过图片超过它的一半宽度之后，上面的mCurView就会切换成下一张图片了，所以我在设置动画的方法里以0.5为一个临界点，因为0.5临界点的两边，mCurView，mRightView，mLeftView的指向都已经不一样了。 假如我们定义大小变化因子 float mAnimFactor = 0.2f，它的意思就是控制我们的图片从1.0伸缩至0.8。以上图为例，当percent &lt;= 0.5时，mCurView的ScaleX和ScaleY从大慢慢变小，至于这个变化范围，就根据我们定义的变化因子和percent来修改；而当percent &gt; 0.5时，刚才那个View就变成了mLeftView，此时我们继续刚才的操作，整个过程我们就实现了第一张图片的Scale从1.0变化到了0.8。而另外两张图片也是同理，大概代码逻辑如下： private void setBottomToTopAnim(RecyclerView recyclerView, int position, float percent) { View mCurView = recyclerView.getLayoutManager().findViewByPosition(position); // 中间页 View mRightView = recyclerView.getLayoutManager().findViewByPosition(position + 1); // 左边页 View mLeftView = recyclerView.getLayoutManager().findViewByPosition(position - 1); // 右边页 if (percent &lt;= 0.5) { if (mLeftView != null) { // 变大 mLeftView.setScaleX((1 - mAnimFactor) + percent * mAnimFactor); mLeftView.setScaleY((1 - mAnimFactor) + percent * mAnimFactor); } if (mCurView != null) { // 变小 mCurView.setScaleX(1 - percent * mAnimFactor); mCurView.setScaleY(1 - percent * mAnimFactor); } if (mRightView != null) { // 变大 mRightView.setScaleX((1 - mAnimFactor) + percent * mAnimFactor); mRightView.setScaleY((1 - mAnimFactor) + percent * mAnimFactor); } } else { if (mLeftView != null) { mLeftView.setScaleX(1 - percent * mAnimFactor); mLeftView.setScaleY(1 - percent * mAnimFactor); } if (mCurView != null) { mCurView.setScaleX((1 - mAnimFactor) + percent * mAnimFactor); mCurView.setScaleY((1 - mAnimFactor) + percent * mAnimFactor); } if (mRightView != null) { mRightView.setScaleX(1 - percent * mAnimFactor); mRightView.setScaleY(1 - percent * mAnimFactor); } } } (4)背景实现高斯模糊高斯模糊有挺多种实现方法的，Google一下就出来了。但是还是推荐Native层的实现算法，因为Java层的实现对性能影响实在太大了，例子里使用的是RenderScript，当然是参考博主湫水的教你一分钟实现动态模糊效果，大家感兴趣可以过去看看，用法也是非常简单。直接调用blurBitmap(Context context, Bitmap image, float blurRadius)方法即可。 public class BlurBitmapUtil { //图片缩放比例 private static final float BITMAP_SCALE = 0.4f; /** * 模糊图片的具体方法 * * @param context 上下文对象 * @param image 需要模糊的图片 * @return 模糊处理后的图片 */ public static Bitmap blurBitmap(Context context, Bitmap image, float blurRadius) { // 计算图片缩小后的长宽 int width = Math.round(image.getWidth() * BITMAP_SCALE); int height = Math.round(image.getHeight() * BITMAP_SCALE); // 将缩小后的图片做为预渲染的图片 Bitmap inputBitmap = Bitmap.createScaledBitmap(image, width, height, false); // 创建一张渲染后的输出图片 Bitmap outputBitmap = Bitmap.createBitmap(inputBitmap); // 创建RenderScript内核对象 RenderScript rs = RenderScript.create(context); // 创建一个模糊效果的RenderScript的工具对象 ScriptIntrinsicBlur blurScript = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs)); // 由于RenderScript并没有使用VM来分配内存,所以需要使用Allocation类来创建和分配内存空间 // 创建Allocation对象的时候其实内存是空的,需要使用copyTo()将数据填充进去 Allocation tmpIn = Allocation.createFromBitmap(rs, inputBitmap); Allocation tmpOut = Allocation.createFromBitmap(rs, outputBitmap); // 设置渲染的模糊程度, 25f是最大模糊度 blurScript.setRadius(blurRadius); // 设置blurScript对象的输入内存 blurScript.setInput(tmpIn); // 将输出数据保存到输出内存中 blurScript.forEach(tmpOut); // 将数据填充到Allocation中 tmpOut.copyTo(outputBitmap); return outputBitmap; } } 这个方法只要传入Context，Bitmap，和一个模糊程度即可，然后返回一个高斯模糊后的Bitmap给我们，我们只需要将RecyclerView的父布局设置背景为这个Bitmap即可。 (5)滑动结束时背景有一个渐变效果，从上一张图片淡入淡出到当前图片实现这个效果最好不要使用Tween动画，因为它的实现效果比较生硬，使用TransitionDrawable会让效果更佳接近淡入淡出效果。那我们怎么记录前后两个位置的照片呢？方法很多种，这里就使用了一个Map来记录每一次显示的图片，在它切换到下一个图片时，便从上一次记录的图片淡入淡出到本次的图片。 // 获取当前位置的图片资源ID int resourceId = ((RecyclerAdapter) mRecyclerView.getAdapter()).getResId(mRecyclerView.getScrolledPosition()); // 将该资源图片转为Bitmap Bitmap resBmp = BitmapFactory.decodeResource(getResources(), resourceId); // 将该Bitmap高斯模糊后返回到resBlurBmp Bitmap resBlurBmp = BlurBitmapUtil.blurBitmap(mRecyclerView.getContext(), resBmp, 15f); // 再将resBlurBmp转为Drawable Drawable resBlurDrawable = new BitmapDrawable(resBlurBmp); // 获取前一页的Drawable Drawable preBlurDrawable = mTSDraCacheMap.get(KEY_PRE_DRAW) == null ? resBlurDrawable : mTSDraCacheMap.get(KEY_PRE_DRAW); /* 以下为淡入淡出效果 */ Drawable[] drawableArr = {preBlurDrawable, resBlurDrawable}; TransitionDrawable transitionDrawable = new TransitionDrawable(drawableArr); mContainer.setBackgroundDrawable(transitionDrawable); transitionDrawable.startTransition(500); // 存入到cache中 mTSDraCacheMap.put(KEY_PRE_DRAW, resBlurDrawable); 更多以上所讲的都是实现的一个思路，虽然效果和小清新搭不上关系哈，但是配了几张小清新的图片还是让我们的程序员生活增添一丝精彩。其实大家实现了基础效果之后，还可以深挖更多辅助功能，例如不同的切换效果，支持横屏，动态修改滑动速度等，相信这个过程可以让你收获良多。 Github：Recyclerview-Gallery","categories":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/学习/"}],"tags":[{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://yoursite.com/tags/RecyclerView/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/学习/"}]},{"title":"Android优化方案之--Fragment的懒加载实现","slug":"Android优化方案之--Fragment的懒加载实现","date":"2017-08-24T08:56:29.000Z","updated":"2018-01-11T09:48:57.254Z","comments":true,"path":"2017/08/24/Android优化方案之--Fragment的懒加载实现/","link":"","permalink":"http://yoursite.com/2017/08/24/Android优化方案之--Fragment的懒加载实现/","excerpt":"","text":"一、背景在Android应用中，ViewPager是我们不可避免使用的一个控件，因为它可以使我们在占用较少空间的同时，增强内容的丰富性，同时以其内部流淌着Google的血液，所以它几乎成了每一个App的标配控件。但是，假如ViewPager的每一个Fragment都需要通过网络拉取数据加载，而ViewPager是默认加载前两项的，所以在很容易造成网络丢包或者网络堵塞等问题，所以Fragment使用懒加载是非常有必要的。 举个栗子： 如上图所示，我们有两个大的Tab：人物和风景。而人物Tab下有三个Tab：美女、帅哥、萌娃三个Tab，风景Tab下有：北京、香港、上海三个Tab。假如当App刚启动时，执行的生命周期如下： 我们可以看到，App会默认加载美女和帅哥两个Fragment，并且它们的生命周期都执行到onStar（）方法，同时加载两个Fragment，假如我们在Fragment加载的时候拉取网络数据，那么就会造成如上所说的网络丢包或者网络堵塞等问题，所以我们为了避免这个问题，就需要实现Fragment的懒加载，当我们对Fragment可见的时候，再进行网络加载数据。 二、实现Fragment懒加载针对背景讨论的问题，我们最终要实现的目标就是，当Fragment对我们可见时，我们才进行网络加载，然后再解析数据，更新UI。针对上面的Demo，我们需要做到如下效果： 要实现起来其实也并不复杂，在Fragment中有一个setUserVisibleHint这个方法，而且这个方法是优于onCreate()方法的，所以也可以作为Fragment的一个生命周期来看待，它会通过isVisibleToUser告诉我们当前Fragment我们是否可见，我们可以在可见的时候再进行网络加载。1public void setUserVisibleHint(boolean isVisibleToUser) 当我们在setUserVisibleHint方法中进行Log输出时，我们可以看到： 只有可见时，我们isVisibleToUser为true，否则为false。所以我们可以重写setUserVisibleHint方法，然后在可见时进行网络加载数据： 123456789@Overridepublic void setUserVisibleHint(boolean isVisibleToUser) &#123; Log.d(&quot;TAG&quot;, mTagName + &quot; setUserVisibleHint() --&gt; isVisibleToUser = &quot; + isVisibleToUser); if (isVisibleToUser) &#123; pullData(); &#125; super.setUserVisibleHint(isVisibleToUser);&#125; 三、根据实际用途使用懒加载由第二部分我们可以知道，setUserVisibleHint(boolean isVisibleToUser)方法是比onCreate更早调用的，但是我们一般在加载数据时，都会在数据加载完成时进行UI更新，所以这就有了一个问题，假如拉取数据是秒回，但是我们还没有进行UI绑定，或者是Adapter初始化等，那么我们就无法更新UI了，所以Fragment给我们提供了另一个方法getUserVisibleHint()，它就是用来判断当前Fragment是否可见，所以我们就可以在一系列变量初始化完成后再判断是否可见，若可见再进行数据拉取： 123456789101112@Overridepublic void onStart() &#123; super.onStart(); Log.d(&quot;TAG&quot;, mTagName + &quot; onStart()&quot;); ... if(getUserVisibleHint()) &#123; pullData(); &#125;&#125; 当然，如果你的网络请求并不需要涉及UI更新，那么就可以直接在setUserVisibleHint(boolean isVisibleToUser)里操作，所以最终还是要根据各自的实际用途来使用。 最后，附上懒加载的Demo：Github/LazyFragment","categories":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/学习/"}],"tags":[{"name":"Fragment优化","slug":"Fragment优化","permalink":"http://yoursite.com/tags/Fragment优化/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/学习/"}]},{"title":"AdPlayBanner：功能丰富、一键式使用的图片轮播插件","slug":"AdPlayBanner：功能丰富、一键式使用的图片轮播插件","date":"2017-07-03T16:00:00.000Z","updated":"2018-01-11T09:44:28.690Z","comments":true,"path":"2017/07/04/AdPlayBanner：功能丰富、一键式使用的图片轮播插件/","link":"","permalink":"http://yoursite.com/2017/07/04/AdPlayBanner：功能丰富、一键式使用的图片轮播插件/","excerpt":"","text":"AdPlayBannerAdPlayBanner是一个Android平台基于ViewPager实现的轮播图插件，主要用以自动或者手动地播放轮播图，提供了Fresco、Picasso、Glide等图片加载方式供用户使用，以及多种图片切换动画，设置轮播时间，设置数据源顺序，提供不同分页指示器等功能，实现了一键式、灵活式的控件使用方式。下面是效果图： 目前AdPlayBanner已经开源到了Github上面，大家可以在Github上面查看本控件的Demo，或者直接使用。 Github地址为：https://github.com/ryanlijianchang/AdPlayBanner 一、使用方法1.添加依赖首先，在项目级别的build.gradle文件添加依赖： allprojects { repositories { ... maven { url &apos;https://jitpack.io&apos; } } } 然后，在模块目录下的build.gradle文件添加依赖： dependencies { compile &apos;com.github.ryanlijianchang:AdPlayBanner:v0.2&apos; } 2.在布局文件中添加控件在布局文件中添加AdPlayBanner控件，根据自己的需要设置高度，注意，控件需要在一个布局（可以是LinearLayout，RelativeLayout，FrameLayout等）之内。 &lt;com.ryane.banner_lib.AdPlayBanner android:id=&quot;@+id/game_banner&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; /&gt; 3.在Activity中绑定控件mAdPlayBanner = (AdPlayBanner) findViewById(R.id.game_banner); 4.添加网络权限由于加载的是网络图片，所以需要在Manifests文件中添加网络请求权限 &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; 5.初始化Fresco默认使用Fresco加载图片，所以按照Fresco官方做法，需要在Application创建时初始化Fresco，常规做法如下： (1) 创建MyApplication类继承Application，然后在onCreate()方法中初始化Fresco： public class MyApplication extends Application { @Override public void onCreate() { super.onCreate(); Fresco.initialize(this); } } (2) 在Manifests文件中标签中增加 android:name=&quot;你的类名&quot;: &lt;application android:name=&quot;.MyApplication&quot; ...&gt; ... &lt;/application&gt; 当然，如果你不使用Fresco加载，以上步骤可以跳过。 6.一键式使用AdPlayBanner使用了Builder设计模式，所以可以通过一键式写法来直接装载AdPlayBanner，当然也可以使用常规写法。在使用之前需要先设置数据源，使用ArrayList来封装数据，而AdPageInfo是一个封装好的Bean类，封装如下： public class AdPageInfo implements Parcelable { public String title; // 广告标题 public String picUrl; // 广告图片url public String clickUlr; // 图片点击url public int order; // 顺序 } 在设置完数据源mDatas之后，使用Builder模式写法，一句话就可以使用AdPlayBanner了。注意，setUp()方法必须在调用完所有API之后，最后调用： mAdPlayBanner.setInfoList(mDatas).setUp(); 当然，你也可以使用常规写法： mAdPlayBanner.setInfoList(mDatas); mAdPlayBanner.setUp(); 7.关闭AdPlayBanner在显示AdPlayBanner的页面生命周期到达onDestroy()时，建议调用mAdPlayBanner.stop()方法结束AdPlayBanner，避免内存泄漏。 二、功能介绍1.自定义数据顺序在调用setUp()方法之前，我们需要设置数据源，每一页的数据使用AdPageInfo来封装，它里面就有一个int型变量order,我们通过给每一个AdPageInfo赋值order，AdPlayBanner就会自动按照order的大小来排序，如： 我们封装了三个数据到ArrayList里面，按顺序是图片1-&gt;图片2-&gt;图片3 List&lt;AdPageInfo&gt; mDatas = new ArrayList&lt;&gt;(); AdPageInfo info1 = new AdPageInfo(&quot;图片1&quot;, &quot;http://osjnd854m.bkt.clouddn.com/pic1_meitu_1.jpg&quot;, &quot;链接1&quot;, 3); AdPageInfo info2 = new AdPageInfo(&quot;图片2&quot;, &quot;http://osjnd854m.bkt.clouddn.com/pic1_meitu_2.jpg&quot;, &quot;链接2&quot;, 2); AdPageInfo info3 = new AdPageInfo(&quot;图片3&quot;, &quot;http://osjnd854m.bkt.clouddn.com/pic1_meitu_3.jpg&quot;, &quot;链接3&quot;, 1); mDatas.add(info1); mDatas.add(info2); mDatas.add(info3); 装载之后运行，可见轮播顺序是按照order的顺序来播放： 2.无限循环轮播很多轮播插件没有实现无限循环轮播这个功能, 而在AdPlayBanner上得到了实现，如下图可见，当我们无限循环滑动时，插件仍能正常运行： 3.支持三种图片加载方式目前比较主流的Fresco、Picasso、Glide三种图片加载方式在AdPlayBanner中都支持，至于三者的区别我就不赘述了，默认是使用Fresco方式加载，具体调用方法setImageLoadType(ImageLoaderType type)，只需要将传入数据设置为：FRESCO、GLIDE、PICASSO其中一种即可，同样，也是可以通过代码一键式使用，例如使用Glide方式加载（其他加载方式使用类似），使用方法如下： mAdPlayBanner .setInfoList((ArrayList&lt;AdPageInfo&gt;) mDatas) .setImageLoadType(Glide) // 设置Glide类型的图片加载方式 .setUp(); 4.支持多种ScaleType在AdPlayBanner中，可以根据用户需要设置图片的ScaleType，具体效果和ImageView的ScaleType一致，默认是使用FIT_XY，但是在AdPlayBanner中比ImageView少了一种MATRIX类型，在AdPlayBanner中具体支持的ScaleType有如下：FIT_XY、FIT_START、FIT_CENTER、FIT_END、CENTER、CENTER_CROP、CENTER_INSIDE其中，具体调用方法setImageViewScaleType(ScaleType scaleType)，只需要将具体的ScaleType传入即可，同样，也是可以通过代码一键式使用，例如设置ScaleType为FIT_START（其他类似），使用方法如下： mAdPlayBanner .setInfoList((ArrayList&lt;AdPageInfo&gt;) mDatas) .setImageViewScaleType(FIT_START) // 设置FIT_START类型的ScaleType .setUp(); 5.支持不同页码指示器在AdPlayBanner中，提供了数字型、点型和空型页码指示器，用户可以通过调用setIndicatorType(IndicatorType type)，传入NONE_INDICATOR，NUMBER_INDICATOR，POINT_INDICATOR其中一种，即可显示对应的页码指示器，三种页码指示器对应效果如下： (1) NONE_INDICATOR：空型页码指示器 (2) NUMBER_INDICATOR：数字页码指示器 (3) POINT_INDICATOR：点型页码指示器 使用方法也是非常简单，如我需要使用数字型页码指示器，使用方法如下： mAdPlayBanner .setInfoList((ArrayList&lt;AdPageInfo&gt;) mDatas) .setIndicatorType(NUMBER_INDICATOR) //使用数字页码指示器 .setUp(); 此外，你也可以调用setNumberViewColor(int normalColor, int selectedColor, int numberColor)来修改数字型页码指示器的样式，normalColor为数字没选中时的背景颜色，selectedColor为数字选中时的背景颜色，numberColor为数字的字体颜色，例如我通过调用这个方法，把三个颜色都改变掉（注意：传入int型颜色必须ARGB8888的颜色类型，或者通过资源文件定义颜色再获取才有效），使用方法如下： mAdPlayBanner .setInfoList((ArrayList&lt;AdPageInfo&gt;) mDatas) .setIndicatorType(NUMBER_INDICATOR) //使用数字页码指示器 .setNumberViewColor(0xff00ffff, 0xffff3333, 0xff0000ff) .setUp(); 得到如下效果： 6.添加灵活性标题在AdPlayBanner中，只需要调用addTitleView(TitleView mTitleView)，就可以插入标题了，并且该标题的灵活性很强，可以根据用户需要修改标题的背景、位置、字体大小、padding、magin等，先上一个提供的默认效果： 由于是使用了默认的效果，所以用法也是非常简单： mAdPlayBanner .setInfoList((ArrayList&lt;AdPageInfo&gt;) mDatas) .setIndicatorType(POINT_INDICATOR) //使用数字页码指示器 .addTitleView(TitleView.getDefaultTitleView(getApplicationContext())) // 使用默认标题 .setUp(); 我们可以看到我们通过调用addTitleView(TitleView mTitleView)，传入一个TitleView即可以生成标题，而上面是调用了AdPlayBanner提供的一个默认标题，当然，我们也说了这个标题的灵活性很强，就是我们可以设置TitleView的属性，我们来看一下TitleView提供了哪些API： TitleView setTitleColor(int color)：设置标题字体颜色，传入color必须ARGB8888的颜色类型，或者通过资源文件定义颜色再获取才有效。 setPosition(Gravity gravity)：设置标题在AdPlayBanner中的位置，有PARENT_TOP,PARENT_BOTTOM,PARENT_CENTER三个取值，分别位于父布局顶部，父布局底部，父布局中间。 setViewBackground(int color)：设置标题的背景颜色，传入int型颜色必须ARGB8888的颜色类型，或者通过资源文件定义颜色再获取才有效。 TitleView setTitleSize(int size)：设置标题的字体大小，单位是sp。 setTitleMargin(int left, int top, int right, int bottom)：设置标题的四个方向margin值，单位是dp。 setTitlePadding(int left, int top, int right, int bottom)：设置标题的四个方向padding值，单位是dp。 同样，TitleView也是支持Builder模式的写法，例如我自定义一个TitleVIew并加到AdPlayBanner中，使用方法如下： mAdPlayBanner .setInfoList((ArrayList&lt;AdPageInfo&gt;) mDatas) .setIndicatorType(POINT_INDICATOR) // 使用数字页码指示器 .addTitleView(new TitleView(getApplicationContext()) // 创建新的TitleView .setPosition(PARENT_TOP) .setTitleColor(0xffffffff) // 设置字体颜色 .setViewBackground(0x9944ff18) // 设置标题背景颜色 .setTitleSize(18) // 设置字体大小 .setTitleMargin(0,0,2,0) // 设置margin值 .setTitlePadding(2,2,2,2)) // 设置padding值 .setUp(); 效果如下： 7.支持多样式切换动画由于AdPlayBanner是基于ViewPager实现的，所以AdPlayBanner和ViewPager一样，同样支持自定义的切换动画，只需要通过调用setPageTransfromer(ViewPager.PageTransformer transformer)方法，传入一个PageTransformer，即可改变它的切换样式，AdPlayBanner中提供了三种现成的切换方式： FadeInFadeOutTransformer：淡入淡出效果 RotateDownTransformer：旋转效果 ZoomOutPageTransformer： 空间切换效果 使用起来也是非常简单，例如使用ZoomOutPageTransformer切换效果： mAdPlayBanner .setInfoList((ArrayList&lt;AdPageInfo&gt;) mDatas) .setIndicatorType(POINT_INDICATOR) // 使用数字页码指示器 .setBannerBackground(0xff000000) // 设置背景颜色 .setPageTransfromer(new ZoomOutPageTransformer()) // 设置切换效果 .setUp(); 当然，你也可以自定义一个transformer实现ViewPager.PageTransformer接口，并重写transformPage(View view, float position)方法即可实现自定义的切换效果。 8.设置是否自动轮播通过调用setAutoPlay(boolean autoPlay),传入boolean值控制是否自动播放的开关，传入true为自动，传入false为手动。 9.设置自动滑动间隔时间通过调用setInterval(int interval)，传入int型的时间（单位ms），即可改变AdPlayBanner自动轮播时的切换时间。 10.设置点击事件监听器AdPlayBanner支持点击事件监听，通过调用setOnPageClickListener(OnPageClickListener l)，传入OnPageClickListener，即可完成AdPlayBanner的点击监听，使用方法非常简单： mAdPlayBanner .setInfoList((ArrayList&lt;AdPageInfo&gt;) mDatas) .setIndicatorType(POINT_INDICATOR) // 使用数字页码指示器 .setOnPageClickListener(new AdPlayBanner.OnPageClickListener() { @Override public void onPageClick(AdPageInfo info, int postion) { // 点击操作 } }) .setUp(); 11.关闭AdPlayBanner在离开显示AdPlayBanner的页面时，建议调用stop()方法，避免内存泄漏。 三、APIAdPlayBanner：实现轮播效果的控件 AdPlayBanner 解释 备注 addTitleView(TitleView mTitleView) 添加一个TitleView 可以通过TitleView.getDefaultTitleView(Context context)来使用默认的TitleView或者通过new Title()的方式传入 setBannerBackground(int color) 设置AdPlayBanner的背景颜色 传入color必须ARGB8888的颜色类型，或者通过资源文件定义颜色再获取才有效 setIndicatorType(IndicatorType type) 设置页码指示器类型 传入NONE_INDICATOR，NUMBER_INDICATOR，POINT_INDICATOR其中一种 setInterval(int interval) 设置自动轮播时的切换时间 单位ms setImageLoadType(ImageLoaderType type) 设置图片加载方式 传入FRESCO、GLIDE、PICASSO其中一种 setPageTransfromer(ViewPager.PageTransformer transformer) 设置切换动画，如果不设置动画，设置为null 提供了FadeInFadeOutTransformer，RotateDownTransformer，ZoomOutPageTransformer三种，也可以传入自定义的TransFormer setNumberViewColor(int normalColor, int selectedColor, int numberColor) 设置数字页码的颜色 normalColor 数字正常背景颜色，selectedColor 数字选中背景颜色，numberColor 数字字体颜色 setOnPageClickListener(OnPageClickListener l) 设置事件点击监听器 传入一个OnPageClickListener setImageViewScaleType(ScaleType scaleType) 设置图片的ScaleType 传入FIT_XY、FIT_START、FIT_CENTER、FIT_END、CENTER、CENTER_CROP、CENTER_INSIDE其中一种 setAutoPlay(boolean autoPlay) 设置是否自动播放 默认为true 自动播放，传入false为手动 setInfoList(ArrayList pageInfos) 设置Banner的数据源 传入必须为AdPageInfo类型的ArrayList setUp() 装载AdPlayBanner 必须在以上所有方法调用完之后才能调用 stop() 结束AdPlayBanner 在离开显示AdPlayBanner页面时调用，避免内存泄漏 TitleView ： 标题控件 TitleView 解释 备注 getDefaultTitleView(Context context) 获取一个默认的TitleView 传入一个Context setTitleSize(int size) 设置字体大小 单位sp setTitleColor(int color) 设置字体颜色 传入color必须ARGB8888的颜色类型，或者通过资源文件定义颜色再获取才有效 setViewBackground(int color) 设置标题背景 传入color必须ARGB8888的颜色类型，或者通过资源文件定义颜色再获取才有效 setPosition(Gravity gravity) 设置标题在Banner的位置 只能PARENT_TOP,PARENT_BOTTOM,PARENT_CENTER其中一个值 setTitleMargin(int left, int top, int right, int bottom) 设置标题的margin值 单位dp setTitlePadding(int left, int top, int right, int bottom) 设置标题的padding值 单位dp AdPageInfo：AdPlayView指定的数据源 AdPageInfo 解释 备注 AdPageInfo(String title, String picUrl, String clickUlr, int order) 构造方法 void setTitle(String title) 设置标题 String getTitle() 获取标题 void setPicUrl(String picUrl) 设置图片源地址 String getPicUrl() 获取图片链接 void setClickUlr(String clickUlr) 设置点击事件地址 String getClickUlr() 获取点击事件链接 void setOrder(int order) 设置排序的优先级 设置了order，AdPlayBanner会根据order的大小由小到大排序 int getOrder() 获取排序优先级 四、版本特性v0.1 基本框架搭建完成； V0.2 支持定义数据顺序； 无限循环轮播； 支持Fresco、Glide、Picasso三种图片加载方式； 支持多种ScaleType； 支持点型、数字型、空型页码指示器；支持修改数字型页码器的样式； 支持灵活性标题；支持修改标题的位置、字体大小、颜色、边距值等属性； 支持多样式切换动画； 支持设置自动轮播开关； 自定义自动滑动间隔时间； 提供点击事件监听器； 支持修改AdPlayBanner的背景颜色； V0.3 修复了静态变量造成的内存泄漏问题; 提供手动结束Banner播放的接口; 五、 Demo如果大家在使用在仍然有问题，可以通过下载Demo来学习，当然，大家更可以通过查看源代码来学习如何自定义一个轮播控件。 六、后记AdPlayBanner作为作者的第一个开源控件，作者也是非常用心认真地完成，这个过程也学习到很多东西，可能其中会遇到很多错误，所以希望大家可以多多包涵，然后把错误提到Issues里面，作者会在看到的第一时间进行修正。在后面的时间里，作者也会将更多的特性加到这个控件里面，所以希望大家可以加个star，以作为对作者的小小鼓励。 当然，如果你想第一时间联系到作者，不妨尝试以下联系方式： Email：liji.anchang@163.com CSDN：http://blog.csdn.net/ljcitworld Github：https://github.com/ryanlijianchang","categories":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/学习/"}],"tags":[{"name":"图片轮播","slug":"图片轮播","permalink":"http://yoursite.com/tags/图片轮播/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/学习/"}]},{"title":"Android基础夯实--重温动画（二）之Frame Animation","slug":"Android基础夯实--重温动画（二）之Frame Animation","date":"2017-03-26T16:00:00.000Z","updated":"2018-01-11T09:58:58.825Z","comments":true,"path":"2017/03/27/Android基础夯实--重温动画（二）之Frame Animation/","link":"","permalink":"http://yoursite.com/2017/03/27/Android基础夯实--重温动画（二）之Frame Animation/","excerpt":"","text":"心灵鸡汤：天下事有难易乎，为之，则难者亦易矣；不为，则易者亦难矣。 摘要当你已经掌握了Tween Animation之后，再来看Frame Animation，你就会顿悟，喔，原来Frame Animation简单多了，那么恭喜你，你已经在Animation这条路上走得越来越远了，当你花十来分钟认真看完这篇文章，你就已经走完了动画这条小路的2/3。 概述我们都知道，在Android系统中，官方给我们提供了两种类型的动画：属性动画(Property Animation) 和 视图动画(View Animation)，而视图动画又包含了两种类型：补间动画(Tween animation) 和 帧动画(Frame animation)。 在上一节我们已经对Tween Animation进行了详细讲解，这一片，我会给大家介绍视图动画的另一种 Frame Animation。 在开发中，除了常用的Tween Animation以外，我们还会用到Frame Animation，就是我们所说的帧动画，之所以要实现帧动画是因为它可以实现类似电影的动态效果，因为我们平时所拍的视频也是通过一张张照片插入每一帧，串联起来，从而实现连续播放的视觉效果，而这Tween Animation是无法实现，只能通过Frame Animation来实现。例如我们常见的App动态引导页，很多都是通过Frame Animation来实现的。 总体来说，Frame Animation实现起来也是比较简单，本文也是主要做一个抛砖引玉，只做基本介绍，更多进阶知识需要大家日后摸索，更权威解释可以看官方文档：Frame Animation。以下先通过Demo给大家更直观地展示Frame Animation。 本文主要对View Animation的Frame Animation做介绍，如果大家有兴趣，可以继续阅读本动画系列其他相关文章，作者也在不断更新完善相关内容，希望大家可以指出有误之处。 Demo这个Demo主要是使用Frame Animation来实现ImageView播放gif图效果。 效果图 代码实现 首先在res/drawable/目录下，增添一个frame.xml文件，里面主要写每一帧播放哪一张照片。最外层标签必须是animation-list，子标签item对应每一帧，每一个item里面的drawable属性对应图片位置、duration对应一帧的时长。 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot;&gt; &lt;item android:drawable=&quot;@drawable/g1&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/g2&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/g3&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/g4&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/g5&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/g6&quot; android:duration=&quot;200&quot; /&gt;&lt;/animation-list&gt; 在Activity中，实现如下代码： //将控件背景设置为我们的AnimationDrawable资源文件 image.setBackgroundResource(R.drawable.frame); mBinding.play.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { //拿到要编译成AnimationDrawable的背景 AnimationDrawable imageAnimation = (AnimationDrawable)image.getBackground(); //开始动画 imageAnimation.start(); } }); Frame Animation在Android的官方文档中，Google对Frame Animation的讲解只是用了比较小的篇幅，可能是因为过于简单，当然，大家通过我上面所说的例子也可以看得出Frame Animation的使用也是非常的简单，下面主要介绍Frame Animation的要点。 文件位置在资源文件夹下：res/drawable/filename.xml 编译在上面的例子我们可以了解到，在Activity中，我们是通过image.getBackground()获取到的对象转为了AnimationDrawable，这是因为在我们的xml文件被编译器编译之后就变成了 AnimationDrawable类。 语法&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=[&quot;true&quot; | &quot;false&quot;] &gt; &lt;item android:drawable=&quot;@[package:]drawable/drawable_resource_name&quot; android:duration=&quot;integer&quot; /&gt; &lt;/animation-list&gt; 标签 &lt; animation-list &gt; ：外层必须要的标签，里面包含一个以上的标签 属性： android:oneshot：true则只运行一次，false则重复动画。 &lt; item &gt; ：每一帧的动画，必须是的子标签。 属性： android:drawable：对应资源文件。 android:duration：每一帧时长。 AnimationDrawableAnimationDrawable就是对应于我们自身定义的xml文件，在Java代码中将xml对象转为了AnimationDrawable之后，我们就可以通过它来获取xml文件里面的属性。 父类AnimationDrawable继承于Object -&gt; Drawable -&gt; DrawableContainer。 接口实现了Runnable, Animatable接口。 XML文件中的变量 android:drawable： 用于该帧的图片。 android:duration： 每一帧的时长。 android:oneshot： true则只运行一次，false则重复动画。 android:variablePadding： 如果true，允许drawable文件的当前状态改变。 android:visible： 是否可见。 方法 void addFrame (Drawable frame, int duration)： 添加一帧动画到动画里面。 int getDuration (int i)： 获取第i帧的时长。 Drawable getFrame (int index)： 获取第i帧的Drawbale。 int getNumberOfFrames ()： 获取共有多少帧。 void inflate (Resources r, XmlPullParser parser, AttributeSet attrs, Resources.Theme theme)： 从XML资源里面加载一个Drawable文件。 boolean isOneShot ()： 判断是否单次播放。 boolean isRunning ()： 判断动画是否还在运行。 Drawable mutate ()： 一个drawable如果使用了mutate()方法，那么对这个drawable属性（包括设置drawable的透明度）修改将不会共享。 void setOneShot (boolean oneShot)： 设置动画播放一次或者循环。 boolean setVisible (boolean visible, boolean restart)： 设置该AnimationDrawable是否可见。 void start ()： 播放。 void stop ()： 停止。 void unscheduleSelf (Runnable what)： 让动画重新回到-1帧。 总结Frame Animation总体来说比较简单，通过XML的划分帧，在Java代码中获取到编译的AnimationDrawable，然后进行播放，难点不多，却是很多引导页的常用实现方法。","categories":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/学习/"}],"tags":[{"name":"动画","slug":"动画","permalink":"http://yoursite.com/tags/动画/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/学习/"}]},{"title":"Android基础夯实--重温动画（一）之Tween Animation","slug":"Android基础夯实--重温动画（一）之Tween Animation","date":"2017-03-20T16:00:00.000Z","updated":"2018-01-11T09:56:08.390Z","comments":true,"path":"2017/03/21/Android基础夯实--重温动画（一）之Tween Animation/","link":"","permalink":"http://yoursite.com/2017/03/21/Android基础夯实--重温动画（一）之Tween Animation/","excerpt":"","text":"心灵鸡汤：真正成功的人生，不在于成就的大小，而在于你是否努力地去实现自我，喊出自己的声音，走出属于自己的道路。 摘要不积跬步，无以至千里；不积小流，无以成江海。学习任何东西我们都离不开扎实的基础知识，这次我们重温Android中让我们又爱又恨的动画。即便没有很好的算法思想，但是掌握了Animation的基础，我们同样可以通过动画给我们的App增色不少。 概述在我们日常开发中，我们都希望我们的App拥有及其炫酷的动画效果，除了一些SDK提供给我们拥有炫酷动画效果的控件外，都需要我们自己来实现。在Android系统中，官方给我们提供了两种类型的动画：属性动画(Property Animation) 和 视图动画(View Animation)，而视图动画又包含了两种类型：补间动画(Tween animation) 和 帧动画(Frame animation)。 Property Animation(属性动画)：通过改变对象的属性来实现动画效果。 View Animation(视图动画)：包括了以下两种动画类型。 Tween Animation(补间动画)：通过对视图进行一系列的动作变化实现动画效果。 Frame Animation(帧动画)：通过一组图片有序播放实现动画视觉效果。 为此，由于篇幅过长，笔主通过三篇博文来重温Animation的相关基础知识，内容主要作为抛砖引玉，围绕这三种动画作简单的介绍，因为所有的动画都是以这几种动画为基础，配合其他的技术，例如自定义View、还有一些曲线函数等，做出很多炫酷的效果。但是，炫酷动画万万千，我们做的每一个动画需求都是源自设计师的灵感，所以这篇文章就不对动画的高阶讲解，相反，是作为抛砖引玉，所以如果你已经非常熟悉动画相关，可以跳过，但是如果你对动画还是不了解，不妨继续看下去。 当然，更权威的解释请查看官方文档：Animation Resources 本文首先对View Animation的Tween Animation做介绍，如果大家有兴趣，可以继续阅读本动画系列其他相关文章，作者也在不断更新完善相关内容，希望大家可以指出有误之处。 Tween Animation，翻译为补间动画，是View Animation两种中的一种，是Android开发中使用最普遍的动画，当然也是使用率最高的一种动画，因为它能够基本满足我们的动画需要，主要是通过对控件实现透明度(alpha)、尺寸(scale)、位置(translate)、旋转rotate)进行改变，通过集合(set)的方式，实现连续的动画效果。 一、动画资源文件的位置 二、类型Tween Animation是View Animation其中之一，Tween Animation可以实现对控件实现以下四种变换: alpha：透明度渐变动画效果 scale：尺寸变化动画效果 translate：位置移动动画效果 rotate：转移旋转动画效果 三、使用方式 在XML文件中定义一系列的动画标签，所有便签在set便签里面构成集合 Java文件中代码实现 之所以可以这样，是因为四个便签都有对应的Java类：AlphaAnimation, RotateAnimation, ScaleAnimation, TranslateAnimation。 所在包：android.view.animation.* 都继承于父类：android.view.animation.Animation 四、Animation类Tween Animation的所有效果都是继承于Animation类，Animation类作为一个抽象类，提供了动画基本属性的实现，需要由具体的子类来具体实现。 直接子类 AnimationSet：代表着一组可以一起播放的动画。 AlphaAnimation：控制一个对象透明度的动画。 RotateAnimation：控制一个对象旋转的动画。 ScaleAnimation：控制一个对象尺寸的动画。 TranslateAnimation：控制一个对象位置的动画。 监听器 Animation.AnimationListener：动画监听器。主要包括监听动画执行中、执行结束、循环执行三个过程。 12345678910111213141516mAnimation.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; // 动画执行时 &#125; @Override public void onAnimationEnd(Animation animation) &#123; // 动画结束时 &#125; @Override public void onAnimationRepeat(Animation animation) &#123; // 动画循环时 &#125; &#125;); 属性及其对应方法(所有子类都拥有) android:detachWallpaper： 是否在壁纸上运行 1Java方法：setDetachWallpaper(boolean detachWallpaper) android:duration： 动画时长，单位毫秒。 1Java方法：setDuration(long) android:fillAfter： 设置为true，控件动画结束时将保持动画最后一帧（xml文件中，需要设置在set便签才生效）。 1Java方法：setFillAfter(boolean) android:fillBefore： 设置为true，控件动画结束时将保持动画开始第一帧（感觉很坑爹，设置true和false还有删除这个属性，效果都一样）。 1Java方法：setFillBefore(boolean) android:fillEnabled： 效果和fillBefore一样（同样坑爹，经测试这个属性可有可无，求打脸。 1Java方法：setFillEnabled(boolean) android:interpolator： 插值器。设置动画速率的变化(譬如加速、减速、匀速等)，后面详说。 1Java方法：setInterpolator(Interpolator) android:repeatCount： 动画重复次数。 1Java方法：setRepeatCount(int) android:repeatMode： 重复模式，有reverse(倒序)和restart(重复)两种，必须配合repeatCount一起使用。 1Java方法：setRepeatMode(int) android:startOffset： 延迟一定毫秒之后才开始动画。 1Java方法：setStartOffset(long) android:zAdjustment： 表示被设置动画的内容在动画运行时在Z轴上的位置，有以下三个值 normal 默认值，保持内容在Z轴上的位置不变 top 保持在Z周最上层 bottom 保持在Z轴最下层1Java方法：setZAdjustment(int) 五、InterpolatorInterpolator，又名插值器，主要是实现动画的速率变化。Interpolator作为一个接口，然后抽象类BaseInterpolator实现Interpolator接口，在BaseInterpolator的子类就是一系列Android提供的插值器。 用法： 在XML的标签下设置:android:interpolator=”@android:anim/accelerate_decelerate_interpolator” 在JAVA代码中使用：animation.setInterpolator(new AccelerateDecelerateInterpolator()); 以下为Andorid所提供的所有插值器： 1、AccelerateDecelerateInterpolator：开始和结束速度慢，中间部分加速。 2、AccelerateInterpolator：开始缓慢，然后加速。 3、AnticipateInterpolator: 开始后退，然后前进。 4、AnticipateOvershootInterpolator: 开始后退，然后前进，直到超出目标值，再后退至目标值。 5、BounceInterpolator：在结束时弹跳。 6、CycleInterpolator：在指定数量的周期内重复动画，速度变化遵循正弦规律。 7、DecelerateInterpolator：开始加速，结束缓慢。 8、LinearInterpolator：匀速。 9、OvershootInterpolator：前进，直到超出目标值，再后退至目标值。 10、PathInterpolator：根据路径变化改变速率。 关于以上所有插值器的Demo： 六、AnimationSetAnimationSet是动画中非常重要的概念，继承于Animation类，它将很多独立的动画包裹到一个集合内，形成一个共同作用的动画效果。例如，我们会在res/anim/目录下的xml文件里面这样实现一个包含多种效果的动画(透明度、尺寸、位置、旋转)： 123456789101112131415161718192021222324252627282930&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fillAfter=&quot;true&quot; android:shareInterpolator=&quot;false&quot;&gt; &lt;scale android:duration=&quot;1500&quot; android:fromXScale=&quot;1.0&quot; android:fromYScale=&quot;1.0&quot; android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toXScale=&quot;1.4&quot; android:toYScale=&quot;0.6&quot; /&gt; &lt;set android:duration=&quot;1000&quot; android:interpolator=&quot;@android:anim/accelerate_interpolator&quot; android:startOffset=&quot;1500&quot;&gt; &lt;scale android:fromXScale=&quot;1.4&quot; android:fromYScale=&quot;0.6&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toXScale=&quot;0.0&quot; android:toYScale=&quot;0.0&quot; /&gt; &lt;rotate android:fromDegrees=&quot;0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toDegrees=&quot;-45&quot; /&gt; &lt;/set&gt;&lt;/set&gt; 效果如下： 当然，你可以使用Java代码来实现，逻辑和在XML中实现的是一样的，如下： 123456789101112131415161718192021222324252627282930313233343536public class MainActivity extends AppCompatActivity &#123; private ActivityMainBinding mainBinding; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main); //参数为false，不共享Interpolator AnimationSet set = new AnimationSet(false); set.setFillAfter(true); // Scale动画 ScaleAnimation scaleAnimation = new ScaleAnimation(1.0f, 1.4f, 1.0f, 0.6f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); scaleAnimation.setInterpolator(new AccelerateDecelerateInterpolator()); scaleAnimation.setDuration(1500); set.addAnimation(scaleAnimation); // mSet集合 AnimationSet mSet = new AnimationSet(true); mSet.setInterpolator(new AccelerateInterpolator()); mSet.setDuration(1000); mSet.setStartOffset(1500); // Scale动画 ScaleAnimation mScaleAnimation = new ScaleAnimation(1.4f, 0.0f, 0.6f, 0.0f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); mSet.addAnimation(mScaleAnimation); // Rotate动画 RotateAnimation mRotateAnimation = new RotateAnimation(0.0f, -45.0f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); mSet.addAnimation(mRotateAnimation); set.addAnimation(mSet); mainBinding.image.startAnimation(set); &#125;&#125; 构造函数 AnimationSet(Context context, AttributeSet attrs) ：当需要加载AttributeSet时使用的构造函数。 AnimationSet(boolean shareInterpolator)：当从代码实现AnimationSet时，传入是否子动画是否共享插值器参数。 主要属性及其方法(父类以外的)Java方法 void addAnimation (Animation a)： 把一个子动画加到Animation Set中去。 long computeDurationHint ()： 获取最长时间的子动画的时间，单位毫秒。 List getAnimations ()： 获取所有子动画对象的集合。 long getStartTime ()：获取动画什么时候应该播放，如果方法返回常量 START_ON_FIRST_FRAME (-1)，表明动画未播放。 **boolean getTransformation (long currentTime, Transformation t)：** 获取帧动画执行到目前时的变换信息，存到Transformation中，主要用作调试用。 例如我们需要当前Scale动画的变换信息： 1234567Transformation tf = new Transformation();if (scaleAnimation!=null)&#123; scaleAnimation.getTransformation(AnimationUtils.currentAnimationTimeMillis(), tf); System.out.println(&quot;Matrix:&quot; + tf.getMatrix()); System.out.println(&quot;Alpha:&quot; + tf.getAlpha()); System.out.println(&quot;TransformationType:&quot; + tf.getTransformationType());&#125; **void initialize (int width, int height, int parentWidth, int parentHeight)：** 初始化动画的宽高和父动画的宽高。 void reset ()： 重置动画的初始状态。 void restrictDuration (long durationMillis)： 限制动画不能超过durationMillis个毫秒。 boolean willChangeBounds ()： 动画是否会改变view的尺寸边界。true为会。 boolean willChangeTransformationMatrix ()： 动画是否会改变view的矩阵。 七、AlphaAnimationAlphaAnimation是继承于Animation的一个动画类型，它通过控制控件的透明度变化来实现动画效果，如我们常见的淡入淡出效果就是通过AlphaAnimaiton实现。 不多说，我们来通过例子看一下AlphaAnimation的实现消失动画效果： 还是有两种写法，一种在XML里定义动画的样式，一种在Java代码里实现动画的样式。 写法一 在res/anim目录下定义alpha.xml文件，在文件内写： 1234&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;2500&quot; android:fromAlpha=&quot;1.0&quot; android:toAlpha=&quot;0.0&quot; /&gt; 在Activity中加载xml文件，并绑定控件播放动画： 12AlphaAnimation animation = (AlphaAnimation) AnimationUtils.loadAnimation(getApplicationContext(), R.anim.alpha);image.startAnimation(animation); 写法二 直接在Java代码中实现： 123AlphaAnimation animation = new AlphaAnimation(1.0f, 0.0f);animation.setDuration(2500);mBinding.image.startAnimation(animation); 构造函数 AlphaAnimation(Context context, AttributeSet attrs)：当需要加载AttributeSet时使用的构造函数。 AlphaAnimation(float fromAlpha, float toAlpha)：构造函数传入fromAlpha(开始时透明度)， toAlpha(结束时透明度) 主要属性及其对应方法(父类以外的)XML属性 android:fromAlpha： 动画开始前控件的透明度，取值0.0-1.0，从透明到不透明。 android:toAlpha： 动画结束时控件的透明度，取值0.0-1.0，从透明到不透明。 Java方法 boolean willChangeBounds ()： 动画是否会改变view的尺寸边界。true为会。 boolean willChangeTransformationMatrix ()： 动画是否会改变view的矩阵。 void applyTransformation (float interpolatedTime, Transformation t)： AlphaAnimation的具体实现，只能在AlphaAnimation的子类中重写来实现自己需要的动画效果。 八、ScaleAnimationScaleAnimation是继承于Animation的一个动画类型，它通过控制控件的尺寸大小来实现动画效果，如我们常见的放大，缩小效果就是通过ScaleAnimation实现。 同样，先示范： 还是有两种写法，一种在XML里定义动画的样式，一种在Java代码里实现动画的样式。 写法一 在res/anim目录下定义scale.xml文件，在文件内写： 123456789101112131415161718192021&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fillAfter=&quot;true&quot;&gt; &lt;scale android:duration=&quot;1500&quot; android:fromXScale=&quot;1.0&quot; android:fromYScale=&quot;1.0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toXScale=&quot;2.0&quot; android:toYScale=&quot;2.0&quot; /&gt; &lt;scale android:duration=&quot;1500&quot; android:fromXScale=&quot;1.0&quot; android:fromYScale=&quot;1.0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:startOffset=&quot;1500&quot; android:toXScale=&quot;0.0&quot; android:toYScale=&quot;0.0&quot; /&gt;&lt;/set&gt; 在Activity中加载xml文件，并绑定控件播放动画： 12Animation animation = AnimationUtils.loadAnimation(getApplicationContext(), R.anim.scale);image.startAnimation(animation); 写法二 在Java代码中实现： 12345678910111213141516AnimationSet set = new AnimationSet(false);set.setFillAfter(true);// 构造函数 fromX, toX, fromY, toY, pivotXType, pivotXValue, pivotYType, pivotYValue// pivotXType和pivotYType都有三种取值：Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, Animation.RELATIVE_TO_PARENTScaleAnimation sa1 = new ScaleAnimation(1.0f, 2.0f, 1.0f, 2.0f, Animation.RELATIVE_TO_SELF,0.5f, Animation.RELATIVE_TO_SELF, 0.5f);sa1.setDuration(1500);ScaleAnimation sa2 = new ScaleAnimation(1.0f, 0.0f, 1.0f, 0.0f, Animation.RELATIVE_TO_SELF,0.5f, Animation.RELATIVE_TO_SELF, 0.5f);sa2.setDuration(1500);sa2.setStartOffset(1500);set.addAnimation(sa1);set.addAnimation(sa2);mBinding.image.startAnimation(set); 构造函数 ScaleAnimation(Context context, AttributeSet attrs)： 当需要加载AttributeSet时使用的构造函数。 ScaleAnimation(float fromX, float toX, float fromY, float toY)： X方向放大（缩小）前的相对比例，X方向放大（缩小）后的相对比例，Y方向放大（缩小）前的相对比例，Y方向放大（缩小）后的相对比例。 ScaleAnimation(float fromX, float toX, float fromY, float toY, float pivotX, float pivotY)： pivotX和pivotY是缩放动画围绕的中心点，当为数值时，表明是屏幕上的绝对坐标值，当为百分数（如50%）时，为相对自己本身控件的比例值，当为百分数加p（如50%p）时，为相对父布局的比例值。 ScaleAnimation(float fromX, float toX, float fromY, float toY, int pivotXType, float pivotXValue, int pivotYType, float pivotYValue)： 当我们需要输入pivotXValue和pivotYValue为百分数或者百分数加p类型的时候，我们用第三个构造函数显示是不行的，这时候需要传入pivotXType和pivotYType，它们有三种取值：Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, Animation.RELATIVE_TO_PARENT。 主要属性及其方法(父类以外的)XML属性 android:fromXScale： 动画开始前的X方向上的尺寸。 android:fromYScale： 动画开始前的Y方向上的尺寸。 android:toXScale： 动画结束时的X方向上的尺寸。 android:toYScale： 动画结束时的Y方向上的尺寸。 android:pivotX： 缩放动画围绕X方向的中心点，当为数值时，表明是屏幕上的绝对坐标值，当为百分数（如50%）时，为相对自己本身控件的比例值，当为百分数加p（如50%p）时，为相对父布局的比例值。 android:pivotY： 缩放动画围绕Y方向的中心点，当为数值时，表明是屏幕上的绝对坐标值，当为百分数（如50%）时，为相对自己本身控件的比例值，当为百分数加p（如50%p）时，为相对父布局的比例值。 Java方法 void initialize (int width, int height, int parentWidth, int parentHeight)： 初始化动画的宽高和父动画的宽高。 九、RotateAnimationRotateAnimation是继承于Animation的一个动画类型，它通过控制控件旋转来实现动画效果，如我们常见的转动效果就是通过RotateAnimation实现。 先看一个小demo： 还是有两种写法，一种在XML里定义动画的样式，一种在Java代码里实现动画的样式。 写法一 在res/anim目录下定义rotate.xml文件，在文件内写： 123456789101112131415161718&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fillAfter=&quot;true&quot;&gt; &lt;rotate android:duration=&quot;1000&quot; android:fromDegrees=&quot;0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toDegrees=&quot;360&quot; /&gt; &lt;rotate android:duration=&quot;1500&quot; android:fromDegrees=&quot;0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:startOffset=&quot;2000&quot; android:toDegrees=&quot;-1800&quot; /&gt;&lt;/set&gt; 在Activity中加载xml文件，并绑定控件播放动画： 12Animation animation = AnimationUtils.loadAnimation(getApplicationContext(), R.anim.rotate);image.startAnimation(animation); 写法二 在Java代码中实现： 1234567891011121314AnimationSet set = new AnimationSet(false);set.setFillAfter(true);RotateAnimation ra1 = new RotateAnimation(0f, 360f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);ra1.setDuration(1000);RotateAnimation ra2 = new RotateAnimation(0f, -1800f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);ra2.setDuration(1500);ra2.setStartOffset(1000);set.addAnimation(ra1);set.addAnimation(ra2);mBinding.image.startAnimation(set); 构造函数 RotateAnimation(Context context, AttributeSet attrs)： 当需要加载AttributeSet时使用的构造函数。 RotateAnimation(float fromDegrees, float toDegrees)：从fromDegress角度转到toDegress角度(正数为顺时针，负数为逆时针)。 RotateAnimation(float fromDegrees, float toDegrees, float pivotX, float pivotY)：加上旋转中心点，X方向中心点pivotX和Y方向中心点，取值仍为上面所介绍的三种。 RotateAnimation(float fromDegrees, float toDegrees, int pivotXType, float pivotXValue, int pivotYType, float pivotYValue)： 加上中心点的取值类型。 主要属性及其方法(父类以外的)XML属性 android:fromDegrees： 动画开始前的角度。 android:toDegrees： 动画结束时的角度。 android:pivotX： 缩放动画围绕X方向的中心点，当为数值时，表明是屏幕上的绝对坐标值，当为百分数（如50%）时，为相对自己本身控件的比例值，当为百分数加p（如50%p）时，为相对父布局的比例值。 android:pivotY： 缩放动画围绕Y方向的中心点，当为数值时，表明是屏幕上的绝对坐标值，当为百分数（如50%）时，为相对自己本身控件的比例值，当为百分数加p（如50%p）时，为相对父布局的比例值。 Java方法 void initialize (int width, int height, int parentWidth, int parentHeight)： 初始化动画的宽高和父动画的宽高。 void applyTransformation (float interpolatedTime, Transformation t)： RotateAnimation的具体实现，只能在RotateAnimation的子类中重写来实现自己需要的动画效果。 十、TranslateAnimationTranslateAnimation是继承于Animation的一个动画类型，它通过控制控件位置变化来实现动画效果，如我们常见的位移效果就是通过TranslateAnimation实现。 TranslationAnimation相关的小Demo，围绕四周转动： 只展示一种写法，Java代码实现方式同上： 在res/anim目录下定义translate.xml文件，在文件内写： 123456789101112131415161718192021222324252627282930313233&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fillAfter=&quot;true&quot;&gt; &lt;translate android:duration=&quot;1000&quot; android:fromXDelta=&quot;0&quot; android:fromYDelta=&quot;0&quot; android:toXDelta=&quot;92%p&quot; android:toYDelta=&quot;0&quot; /&gt; &lt;translate android:duration=&quot;1000&quot; android:fromXDelta=&quot;0&quot; android:fromYDelta=&quot;0&quot; android:startOffset=&quot;1000&quot; android:toXDelta=&quot;0&quot; android:toYDelta=&quot;94%p&quot; /&gt; &lt;translate android:duration=&quot;1000&quot; android:fromXDelta=&quot;0&quot; android:fromYDelta=&quot;0&quot; android:startOffset=&quot;2000&quot; android:toXDelta=&quot;-92%p&quot; android:toYDelta=&quot;0&quot; /&gt; &lt;translate android:duration=&quot;1000&quot; android:fromXDelta=&quot;0&quot; android:fromYDelta=&quot;0&quot; android:startOffset=&quot;3000&quot; android:toXDelta=&quot;0&quot; android:toYDelta=&quot;-94%p&quot; /&gt;&lt;/set&gt; 在Activity中加载xml文件，并绑定控件播放动画： 12Animation animation = AnimationUtils.loadAnimation(getApplicationContext(), R.anim.translate);mBinding.image.startAnimation(animation); 构造函数 TranslateAnimation(Context context, AttributeSet attrs)： 当需要加载AttributeSet时使用的构造函数。 TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta)： fromXDelta（动画开始时的X方向上的位置），toXDelta（动画结束始时的X方向上的位置），fromYDelta（动画开始时的Y方向上的位置），toYDelta（动画结束始时的Y方向上的位置） TranslateAnimation(int fromXType, float fromXValue, int toXType, float toXValue, int fromYType, float fromYValue, int toYType, float toYValue)： 加上类型参数。 主要属性及其方法(父类以外的)Java方法 void initialize (int width, int height, int parentWidth, int parentHeight)： 初始化动画的宽高和父动画的宽高。 void applyTransformation (float interpolatedTime, Transformation t)： TranslateAnimation的具体实现，只能在TranslateAnimation的子类中重写来实现自己需要的动画效果。 总结对于很多比较少接触动画的同学，可能都会比较反感，因为觉得动画篇的东西又多又难学，其实不然，就像我们这篇所介绍的Tween Animation，虽然有很多种动画类型，但是几种都是基于父类Animation类，然后在它的基础上进行了稍微扩展，所以当我们认真静下来去看的时候，我们会发现，其实也不过如此。Animation在实际开发中非常常见，尤其本篇所说的最基本的Tween Animation。在Android已经达到了如此成熟的今天，市场上的应用很大一部分依靠炫酷的动画效果来吸引用户，所以掌握动画会帮助你在日后开发中有很大的帮助，不说其他，早点下班是必须的。","categories":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/学习/"}],"tags":[{"name":"动画","slug":"动画","permalink":"http://yoursite.com/tags/动画/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/学习/"}]}]}